<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZT6JM33V5J"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-ZT6JM33V5J');
        </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Chooser Interactive</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }
        
        .chart-canvas {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .control-button {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
        }
        
        .control-button:hover {
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(139, 92, 246, 0.4);
        }
        
        .control-button:active {
            transform: translateY(0);
        }
        
        .secondary-button {
            background: transparent;
            border: 2px solid #374151;
            color: #9ca3af;
            transition: all 0.3s ease;
        }
        
        .secondary-button:hover {
            border-color: #8b5cf6;
            color: #a78bfa;
            background: rgba(139, 92, 246, 0.1);
        }
        
        .goal-select {
            background: #1f2937;
            border: 2px solid #374151;
            color: #f3f4f6;
            transition: all 0.3s ease;
        }
        
        .goal-select:focus {
            border-color: #8b5cf6;
            outline: none;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
        }
        
        .panel {
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .chart-recommendation {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.1) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 12px;
        }
        
        .poor-choice {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.1) 100%);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
        }
        
        .chart-enter {
            animation: chartEnter 0.5s ease-out;
        }
        
        @keyframes chartEnter {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .data-point {
            transition: all 0.3s ease;
        }
        
        .social-icon {
            transition: all 0.3s ease;
            color: #9ca3af;
        }
        
        .social-icon:hover {
            color: #a78bfa;
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="bg-[#101827] text-[#f3f4f6] min-h-screen flex flex-col">
    
    <!-- Header -->
    <header class="border-b border-[#374151] p-6">
        <h1 class="text-3xl font-bold text-center">Chart Chooser Interactive</h1>
    </header>
    
    <!-- Main Content Grid -->
    <main class="flex-1 grid grid-cols-1 lg:grid-cols-3 gap-6 p-6 min-h-0">
        
        <!-- Panel 1: Controls -->
        <aside class="panel p-6 space-y-6">
            <div>
                <label for="goal-select" class="block text-sm font-medium text-[#9ca3af] mb-3">
                    My data needs to...
                </label>
                <select id="goal-select" class="goal-select w-full p-3 rounded-lg font-mono">
                    <option value="comparison">Show a comparison between items</option>
                    <option value="trend">Show a trend over time</option>
                    <option value="composition">Show a part-to-whole composition</option>
                    <option value="relationship">Show the relationship between variables</option>
                    <option value="distribution">Show the distribution of data</option>
                    <option value="heatmap">Show patterns in two-dimensional data</option>
                    <option value="radar">Compare multiple variables across categories</option>
                    <option value="treemap">Show hierarchical data structure</option>
                    <option value="boxplot">Show statistical distribution with quartiles</option>
                </select>
            </div>
            
            <div class="space-y-3">
                <button id="randomize-btn" class="control-button w-full py-3 px-4 rounded-lg font-medium text-white">
                    <i class="fas fa-dice mr-2"></i>
                    Randomize Data
                </button>
                
                <button id="reset-btn" class="secondary-button w-full py-3 px-4 rounded-lg font-medium">
                    <i class="fas fa-undo mr-2"></i>
                    Reset
                </button>
            </div>
            
            <div class="mt-8 text-sm text-[#9ca3af]">
                <p class="leading-relaxed">
                    Select a data visualization goal to see the recommended chart type and understand why it's the best choice for your data story.
                </p>
            </div>
        </aside>
        
        <!-- Panel 2: Visualization -->
        <section class="panel p-6 flex flex-col">
            <div class="flex-1 flex items-center justify-center">
                <canvas id="chart-canvas" class="chart-canvas max-w-full max-h-full" width="400" height="300"></canvas>
            </div>
        </section>
        
        <!-- Panel 3: Rationale -->
        <aside class="panel p-6 space-y-6">
            <div id="chart-recommendation" class="chart-recommendation p-4">
                <h2 class="text-xl font-bold text-[#10b981] mb-3">
                    <i class="fas fa-circle-check mr-2"></i>
                    <span id="recommended-chart">Bar Chart</span>
                </h2>
                <p id="chart-explanation" class="text-[#f3f4f6] leading-relaxed">
                    Bar charts are ideal for comparing discrete categories or items. They make it easy to see which categories have higher or lower values at a glance.
                </p>
            </div>
            
            <div>
                <h3 class="text-lg font-medium text-[#f3f4f6] mb-4">Alternative Options:</h3>
                <div id="alternative-charts" class="space-y-3">
                    <!-- Dynamic alternatives will be populated here -->
                </div>
            </div>
        </aside>
        
    </main>
    
    <!-- Footer -->
    <footer class="bg-[#1f2937] border-t border-[#374151] p-6 mt-auto">
        <div class="flex justify-center space-x-6">
            <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank" aria-label="LinkedIn" class="social-icon">
                <i class="fab fa-linkedin fa-2x"></i>
            </a>
            <a href="https://github.com/AshishJangra27" target="_blank" aria-label="GitHub" class="social-icon">
                <i class="fab fa-github fa-2x"></i>
            </a>
            <a href="https://www.kaggle.com/ashishjangra27" target="_blank" aria-label="Kaggle" class="social-icon">
                <i class="fab fa-kaggle fa-2x"></i>
            </a>
            <a href="https://huggingface.co/ashish-jangra" target="_blank" aria-label="Hugging Face" class="social-icon">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v-.07zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
            </a>
            <a href="https://www.instagram.com/ashish_zangra/" target="_blank" aria-label="Instagram" class="social-icon">
                <i class="fab fa-instagram fa-2x"></i>
            </a>
        </div>
    </footer>
    
    <script>
        // Chart configuration and data
        const chartConfig = {
            comparison: {
                name: "Bar Chart",
                explanation: "Bar charts are ideal for comparing discrete categories or items. They make it easy to see which categories have higher or lower values at a glance, with clear visual hierarchy.",
                alternatives: [
                    { name: "Line Chart", reason: "Poor choice - Line charts are for trends over time, not category comparison" },
                    { name: "Pie Chart", reason: "Poor choice - Pie charts are for part-to-whole relationships, not comparisons" },
                    { name: "Scatter Plot", reason: "Poor choice - Scatter plots show relationships between variables, not category comparison" }
                ],
                dataGenerator: () => ({
                    labels: ["Product A", "Product B", "Product C", "Product D", "Product E"],
                    values: Array.from({length: 5}, () => Math.random() * 100 + 20)
                })
            },
            trend: {
                name: "Line Chart",
                explanation: "Line charts excel at showing trends and changes over time. The connected points create a clear visual narrative of how values evolve across temporal sequences.",
                alternatives: [
                    { name: "Bar Chart", reason: "Poor choice - Bar charts are for category comparison, not temporal trends" },
                    { name: "Pie Chart", reason: "Poor choice - Pie charts cannot show changes over time effectively" },
                    { name: "Scatter Plot", reason: "Acceptable but not optimal - Missing the connected trend line clarity" }
                ],
                dataGenerator: () => ({
                    labels: ["Jan", "Feb", "Mar", "Apr", "May", "Jun"],
                    values: Array.from({length: 6}, (_, i) => 30 + Math.sin(i * 0.5) * 20 + Math.random() * 15)
                })
            },
            composition: {
                name: "Pie Chart",
                explanation: "Pie charts are perfect for showing part-to-whole relationships. They immediately communicate how different segments contribute to the total, making proportions visually intuitive.",
                alternatives: [
                    { name: "Bar Chart", reason: "Acceptable alternative - Can show composition but less intuitive for proportions" },
                    { name: "Line Chart", reason: "Poor choice - Cannot effectively show part-to-whole relationships" },
                    { name: "Scatter Plot", reason: "Poor choice - Scatter plots are for variable relationships, not composition" }
                ],
                dataGenerator: () => ({
                    labels: ["Mobile", "Desktop", "Tablet", "Smart TV", "Other"],
                    values: [45, 30, 15, 7, 3]
                })
            },
            relationship: {
                name: "Scatter Plot",
                explanation: "Scatter plots reveal relationships and correlations between two variables. Each point represents an observation, making patterns, clusters, and outliers clearly visible.",
                alternatives: [
                    { name: "Line Chart", reason: "Poor choice - Line charts are for trends, not variable relationships" },
                    { name: "Bar Chart", reason: "Poor choice - Cannot show two-variable relationships effectively" },
                    { name: "Pie Chart", reason: "Poor choice - Pie charts are for composition, not variable correlation" }
                ],
                dataGenerator: () => ({
                    points: Array.from({length: 25}, () => ({
                        x: Math.random() * 80 + 10,
                        y: Math.random() * 60 + 20 + (Math.random() - 0.5) * 30
                    }))
                })
            },
            distribution: {
                name: "Histogram",
                explanation: "Histograms show the distribution and frequency of data values. They reveal the shape of your data - whether it's normal, skewed, or has multiple peaks.",
                alternatives: [
                    { name: "Box Plot", reason: "Good alternative - Shows distribution summary but less detailed than histogram" },
                    { name: "Pie Chart", reason: "Poor choice - Cannot show data distribution or frequency patterns" },
                    { name: "Line Chart", reason: "Poor choice - Line charts are for trends, not distribution patterns" }
                ],
                dataGenerator: () => ({
                    bins: [5, 12, 18, 25, 32, 28, 22, 15, 8, 4],
                    labels: ["0-10", "10-20", "20-30", "30-40", "40-50", "50-60", "60-70", "70-80", "80-90", "90-100"]
                })
            },
            heatmap: {
                name: "Heatmap",
                explanation: "Heatmaps visualize data through variations in coloring. They're excellent for showing patterns, correlations, and intensity of data across two dimensions, making complex data relationships immediately apparent.",
                alternatives: [
                    { name: "Scatter Plot", reason: "Poor choice - Cannot show density or intensity patterns effectively" },
                    { name: "Bar Chart", reason: "Poor choice - Cannot represent two-dimensional data patterns" },
                    { name: "Line Chart", reason: "Poor choice - Line charts cannot show 2D data intensity" }
                ],
                dataGenerator: () => ({
                    matrix: Array.from({length: 8}, () => 
                        Array.from({length: 8}, () => Math.random() * 100)
                    ),
                    xLabels: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Avg"],
                    yLabels: ["9AM", "11AM", "1PM", "3PM", "5PM", "7PM", "9PM", "11PM"]
                })
            },
            radar: {
                name: "Radar Chart",
                explanation: "Radar charts compare multiple quantitative variables simultaneously. They show performance across different metrics in a circular format, making it easy to identify strengths and weaknesses.",
                alternatives: [
                    { name: "Bar Chart", reason: "Acceptable but limited - Shows comparison but loses multidimensional perspective" },
                    { name: "Line Chart", reason: "Poor choice - Cannot effectively compare multiple variables simultaneously" },
                    { name: "Pie Chart", reason: "Poor choice - Pie charts are for composition, not multi-variable comparison" }
                ],
                dataGenerator: () => ({
                    labels: ["Speed", "Quality", "Cost", "Reliability", "Innovation", "Support"],
                    datasets: [
                        {
                            name: "Product A",
                            values: Array.from({length: 6}, () => Math.random() * 80 + 20)
                        },
                        {
                            name: "Product B", 
                            values: Array.from({length: 6}, () => Math.random() * 80 + 20)
                        }
                    ]
                })
            },
            treemap: {
                name: "Treemap",
                explanation: "Treemaps display hierarchical data using nested rectangles. The size of each rectangle is proportional to the data value, making it perfect for showing both hierarchy and magnitude simultaneously.",
                alternatives: [
                    { name: "Pie Chart", reason: "Limited alternative - Shows proportions but not hierarchy effectively" },
                    { name: "Bar Chart", reason: "Poor choice - Cannot show hierarchical relationships" },
                    { name: "Scatter Plot", reason: "Poor choice - Scatter plots don't represent hierarchical data" }
                ],
                dataGenerator: () => ({
                    categories: [
                        { name: "Technology", value: 45, color: '#8b5cf6' },
                        { name: "Healthcare", value: 28, color: '#a78bfa' },
                        { name: "Finance", value: 35, color: '#c4b5fd' },
                        { name: "Education", value: 22, color: '#ddd6fe' },
                        { name: "Retail", value: 18, color: '#ede9fe' },
                        { name: "Manufacturing", value: 32, color: '#7c3aed' }
                    ]
                })
            },
            boxplot: {
                name: "Box Plot",
                explanation: "Box plots display the distribution of data through quartiles, showing median, quartiles, and outliers. They're excellent for comparing distributions and identifying statistical patterns across categories.",
                alternatives: [
                    { name: "Histogram", reason: "Good alternative - Shows distribution but for single dataset only" },
                    { name: "Bar Chart", reason: "Poor choice - Cannot show statistical distribution effectively" },
                    { name: "Pie Chart", reason: "Poor choice - Pie charts don't represent statistical distributions" }
                ],
                dataGenerator: () => ({
                    datasets: [
                        {
                            name: "Dataset A",
                            min: 15,
                            q1: 25,
                            median: 40,
                            q3: 60,
                            max: 85,
                            outliers: [10, 90, 95]
                        },
                        {
                            name: "Dataset B",
                            min: 20,
                            q1: 35,
                            median: 50,
                            q3: 70,
                            max: 80,
                            outliers: [12, 88]
                        },
                        {
                            name: "Dataset C",
                            min: 10,
                            q1: 30,
                            median: 45,
                            q3: 65,
                            max: 90,
                            outliers: [5, 95, 98]
                        }
                    ]
                })
            }
        };

        // State management
        let currentGoal = 'comparison';
        let currentData = null;
        let animationId = null;

        // Canvas and context
        const canvas = document.getElementById('chart-canvas');
        const ctx = canvas.getContext('2d');

        // Set up canvas dimensions
        function setupCanvas() {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = 400 * dpr;
            canvas.height = 300 * dpr;
            canvas.style.width = '400px';
            canvas.style.height = '300px';
            
            ctx.scale(dpr, dpr);
        }

        // Chart drawing functions
        function drawBarChart(data) {
            const { labels, values } = data;
            const padding = 60;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            const barWidth = chartWidth / labels.length * 0.7;
            const barSpacing = chartWidth / labels.length * 0.3;
            
            const maxValue = Math.max(...values);
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            // Draw bars
            values.forEach((value, i) => {
                const barHeight = (value / maxValue) * chartHeight;
                const x = padding + i * (barWidth + barSpacing) + barSpacing / 2;
                const y = 300 - padding - barHeight;
                
                // Bar gradient
                const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                gradient.addColorStop(0, '#8b5cf6');
                gradient.addColorStop(1, '#7c3aed');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Bar border
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // Value labels
                ctx.fillStyle = '#f3f4f6';
                ctx.font = '12px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(value), x + barWidth / 2, y - 5);
                
                // Category labels
                ctx.fillStyle = '#9ca3af';
                ctx.font = '10px Roboto Mono';
                ctx.fillText(labels[i], x + barWidth / 2, 300 - padding + 20);
            });
        }

        function drawLineChart(data) {
            const { labels, values } = data;
            const padding = 60;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            const valueRange = maxValue - minValue;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            // Draw grid lines
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(400 - padding, y);
                ctx.stroke();
            }
            
            // Draw line
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            values.forEach((value, i) => {
                const x = padding + (chartWidth / (values.length - 1)) * i;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Draw points
            values.forEach((value, i) => {
                const x = padding + (chartWidth / (values.length - 1)) * i;
                const y = padding + chartHeight - ((value - minValue) / valueRange) * chartHeight;
                
                ctx.fillStyle = '#a78bfa';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#9ca3af';
                ctx.font = '10px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText(labels[i], x, 300 - padding + 20);
            });
        }

        function drawPieChart(data) {
            const { labels, values } = data;
            const centerX = 200;
            const centerY = 150;
            const radius = 80;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            const total = values.reduce((sum, val) => sum + val, 0);
            let currentAngle = -Math.PI / 2;
            
            const colors = ['#8b5cf6', '#a78bfa', '#c4b5fd', '#ddd6fe', '#ede9fe'];
            
            values.forEach((value, i) => {
                const sliceAngle = (value / total) * Math.PI * 2;
                
                ctx.fillStyle = colors[i % colors.length];
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Labels
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelX = centerX + Math.cos(labelAngle) * (radius + 20);
                const labelY = centerY + Math.sin(labelAngle) * (radius + 20);
                
                ctx.fillStyle = '#f3f4f6';
                ctx.font = '10px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`${labels[i]}`, labelX, labelY);
                ctx.fillText(`${value}%`, labelX, labelY + 12);
                
                currentAngle += sliceAngle;
            });
        }

        function drawScatterPlot(data) {
            const { points } = data;
            const padding = 60;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            // Draw grid
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const x = padding + (chartWidth / 5) * i;
                const y = padding + (chartHeight / 5) * i;
                
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, 300 - padding);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(400 - padding, y);
                ctx.stroke();
            }
            
            // Draw points
            points.forEach(point => {
                const x = padding + (point.x / 100) * chartWidth;
                const y = padding + chartHeight - (point.y / 100) * chartHeight;
                
                ctx.fillStyle = '#8b5cf6';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawHeatmap(data) {
            const { matrix, xLabels, yLabels } = data;
            const padding = 60;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            const cellWidth = chartWidth / matrix[0].length;
            const cellHeight = chartHeight / matrix.length;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            const maxValue = Math.max(...matrix.flat());
            
            matrix.forEach((row, i) => {
                row.forEach((value, j) => {
                    const x = padding + j * cellWidth;
                    const y = padding + i * cellHeight;
                    const intensity = value / maxValue;
                    
                    // Color based on intensity
                    const r = Math.floor(139 + intensity * (167 - 139));
                    const g = Math.floor(92 + intensity * (139 - 92));
                    const b = Math.floor(246 + intensity * (250 - 246));
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, cellWidth - 1, cellHeight - 1);
                    
                    // Value text
                    ctx.fillStyle = intensity > 0.7 ? '#ffffff' : '#374151';
                    ctx.font = '8px Roboto Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.round(value), x + cellWidth/2, y + cellHeight/2 + 3);
                });
            });
            
            // Labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '9px Roboto Mono';
            ctx.textAlign = 'center';
            
            xLabels.forEach((label, i) => {
                ctx.fillText(label, padding + i * cellWidth + cellWidth/2, 300 - padding + 15);
            });
            
            ctx.textAlign = 'right';
            yLabels.forEach((label, i) => {
                ctx.fillText(label, padding - 10, padding + i * cellHeight + cellHeight/2 + 3);
            });
        }

        function drawRadarChart(data) {
            const { labels, datasets } = data;
            const centerX = 200;
            const centerY = 150;
            const radius = 80;
            const numPoints = labels.length;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            // Draw grid circles
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (radius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw axes
            for (let i = 0; i < numPoints; i++) {
                const angle = (i * 2 * Math.PI) / numPoints - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Labels
                const labelX = centerX + Math.cos(angle) * (radius + 20);
                const labelY = centerY + Math.sin(angle) * (radius + 20);
                
                ctx.fillStyle = '#f3f4f6';
                ctx.font = '10px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // Draw datasets
            const colors = ['#8b5cf6', '#a78bfa'];
            datasets.forEach((dataset, datasetIndex) => {
                ctx.strokeStyle = colors[datasetIndex];
                ctx.fillStyle = colors[datasetIndex] + '20';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                dataset.values.forEach((value, i) => {
                    const angle = (i * 2 * Math.PI) / numPoints - Math.PI / 2;
                    const distance = (value / 100) * radius;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = colors[datasetIndex];
                dataset.values.forEach((value, i) => {
                    const angle = (i * 2 * Math.PI) / numPoints - Math.PI / 2;
                    const distance = (value / 100) * radius;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        }

        function drawTreemap(data) {
            const { categories } = data;
            const padding = 20;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            const total = categories.reduce((sum, cat) => sum + cat.value, 0);
            let currentArea = 0;
            
            categories.forEach((category, i) => {
                const proportion = category.value / total;
                const area = proportion * chartWidth * chartHeight;
                
                // Simple layout algorithm
                const width = Math.sqrt(area * (chartWidth / chartHeight));
                const height = area / width;
                
                const x = padding + (currentArea % chartWidth);
                const y = padding + Math.floor(currentArea / chartWidth) * height;
                
                ctx.fillStyle = category.color;
                ctx.fillRect(x, y, width, height);
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
                
                // Label
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText(category.name, x + width/2, y + height/2 - 5);
                ctx.fillText(category.value.toString(), x + width/2, y + height/2 + 8);
                
                currentArea += width;
            });
        }

        function drawBoxPlot(data) {
            const { datasets } = data;
            const padding = 60;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            const boxWidth = chartWidth / datasets.length * 0.6;
            const boxSpacing = chartWidth / datasets.length * 0.4;
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            const globalMax = Math.max(...datasets.map(d => Math.max(d.max, ...d.outliers)));
            const globalMin = Math.min(...datasets.map(d => Math.min(d.min, ...d.outliers)));
            const range = globalMax - globalMin;
            
            datasets.forEach((dataset, i) => {
                const x = padding + i * (boxWidth + boxSpacing) + boxSpacing / 2;
                const centerX = x + boxWidth / 2;
                
                // Scale values
                const scaleY = (val) => 300 - padding - ((val - globalMin) / range) * chartHeight;
                
                const minY = scaleY(dataset.min);
                const q1Y = scaleY(dataset.q1);
                const medianY = scaleY(dataset.median);
                const q3Y = scaleY(dataset.q3);
                const maxY = scaleY(dataset.max);
                
                // Draw whiskers
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 2;
                
                // Min whisker
                ctx.beginPath();
                ctx.moveTo(centerX, minY);
                ctx.lineTo(centerX, q1Y);
                ctx.stroke();
                
                // Max whisker
                ctx.beginPath();
                ctx.moveTo(centerX, q3Y);
                ctx.lineTo(centerX, maxY);
                ctx.stroke();
                
                // Whisker caps
                ctx.beginPath();
                ctx.moveTo(centerX - boxWidth/4, minY);
                ctx.lineTo(centerX + boxWidth/4, minY);
                ctx.moveTo(centerX - boxWidth/4, maxY);
                ctx.lineTo(centerX + boxWidth/4, maxY);
                ctx.stroke();
                
                // Draw box
                ctx.fillStyle = '#8b5cf640';
                ctx.fillRect(x, q3Y, boxWidth, q1Y - q3Y);
                ctx.strokeRect(x, q3Y, boxWidth, q1Y - q3Y);
                
                // Draw median line
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, medianY);
                ctx.lineTo(x + boxWidth, medianY);
                ctx.stroke();
                
                // Draw outliers
                ctx.fillStyle = '#ef4444';
                dataset.outliers.forEach(outlier => {
                    const outlierY = scaleY(outlier);
                    ctx.beginPath();
                    ctx.arc(centerX, outlierY, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#9ca3af';
                ctx.font = '10px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.fillText(dataset.name, centerX, 300 - padding + 20);
            });
        }

        function drawHistogram(data) {
            const { bins, labels } = data;
            const padding = 60;
            const chartWidth = 400 - padding * 2;
            const chartHeight = 300 - padding * 2;
            const barWidth = chartWidth / bins.length;
            
            const maxBin = Math.max(...bins);
            
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, 0, 400, 300);
            
            bins.forEach((bin, i) => {
                const barHeight = (bin / maxBin) * chartHeight;
                const x = padding + i * barWidth;
                const y = 300 - padding - barHeight;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                gradient.addColorStop(0, '#8b5cf6');
                gradient.addColorStop(1, '#7c3aed');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth - 2, barHeight);
                
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, barWidth - 2, barHeight);
                
                // Labels
                if (i % 2 === 0) {
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '8px Roboto Mono';
                    ctx.textAlign = 'center';
                    ctx.fillText(labels[i], x + barWidth / 2, 300 - padding + 15);
                }
            });
        }

        // Update UI functions
        function updateChart() {
            const config = chartConfig[currentGoal];
            currentData = config.dataGenerator();
            
            // Add enter animation
            canvas.classList.remove('chart-enter');
            void canvas.offsetWidth; // Force reflow
            canvas.classList.add('chart-enter');
            
            // Clear and draw new chart
            ctx.clearRect(0, 0, 400, 300);
            
            switch (currentGoal) {
                case 'comparison':
                    drawBarChart(currentData);
                    break;
                case 'trend':
                    drawLineChart(currentData);
                    break;
                case 'composition':
                    drawPieChart(currentData);
                    break;
                case 'relationship':
                    drawScatterPlot(currentData);
                    break;
                case 'distribution':
                    drawHistogram(currentData);
                    break;
                case 'heatmap':
                    drawHeatmap(currentData);
                    break;
                case 'radar':
                    drawRadarChart(currentData);
                    break;
                case 'treemap':
                    drawTreemap(currentData);
                    break;
                case 'boxplot':
                    drawBoxPlot(currentData);
                    break;
            }
        }

        function updateRationale() {
            const config = chartConfig[currentGoal];
            
            document.getElementById('recommended-chart').textContent = config.name;
            document.getElementById('chart-explanation').textContent = config.explanation;
            
            const alternativesContainer = document.getElementById('alternative-charts');
            alternativesContainer.innerHTML = '';
            
            config.alternatives.forEach(alt => {
                const altDiv = document.createElement('div');
                altDiv.className = 'poor-choice p-3';
                altDiv.innerHTML = `
                    <div class="flex items-start space-x-2">
                        <i class="fas fa-circle-xmark text-red-400 mt-1 flex-shrink-0"></i>
                        <div>
                            <span class="font-medium text-red-300">${alt.name}</span>
                            <p class="text-sm text-[#9ca3af] mt-1">${alt.reason}</p>
                        </div>
                    </div>
                `;
                alternativesContainer.appendChild(altDiv);
            });
        }

        // Event listeners
        document.getElementById('goal-select').addEventListener('change', (e) => {
            currentGoal = e.target.value;
            updateChart();
            updateRationale();
        });

        document.getElementById('randomize-btn').addEventListener('click', () => {
            // Add button feedback animation
            const button = document.getElementById('randomize-btn');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
                button.style.transform = '';
            }, 150);
            
            // Generate new data and update chart
            updateChart();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            // Add button feedback animation
            const button = document.getElementById('reset-btn');
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
                button.style.transform = '';
            }, 150);
            
            // Reset to default state
            document.getElementById('goal-select').value = 'comparison';
            currentGoal = 'comparison';
            updateChart();
            updateRationale();
        });

        // Initialize app
        function init() {
            setupCanvas();
            updateChart();
            updateRationale();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            setupCanvas();
            updateChart();
        });

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
