<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Search Algorithm</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-main: #101827;
            --bg-panel: #1f2937;
            --accent: #8b5cf6;
            --accent-light: #a78bfa;
            --text-primary: #f3f4f6;
            --text-secondary: #9ca3af;
            --border: #374151;
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--bg-main);
            color: var(--text-primary);
        }

        .grid-cell {
            width: 25px;
            height: 25px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            font-size: 8px;
            font-weight: bold;
        }

        .grid-cell:hover {
            border-color: var(--accent);
        }

        .cell-empty {
            background: var(--bg-panel);
        }

        .cell-wall {
            background: var(--border);
            cursor: not-allowed;
        }

        .cell-start {
            background: #10b981;
            color: white;
        }

        .cell-goal {
            background: #ef4444;
            color: white;
        }

        .cell-open {
            background: #06d6a0;
            color: #0f172a;
            animation: openPulse 0.8s ease-in-out;
        }

        .cell-closed {
            background: var(--accent);
            color: white;
        }

        .cell-path {
            background: #f59e0b;
            color: #0f172a;
            animation: pathPulse 1.5s infinite;
        }

        .cell-current {
            background: #fbbf24;
            color: #0f172a;
            animation: currentPulse 1s infinite;
        }

        @keyframes openPulse {
            0% { transform: scale(0.9); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pathPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes currentPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .f-score {
            position: absolute;
            top: 1px;
            left: 1px;
            font-size: 6px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 1px;
            border-radius: 1px;
            line-height: 1;
        }

        .g-score {
            position: absolute;
            bottom: 1px;
            left: 1px;
            font-size: 6px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 1px;
            border-radius: 1px;
            line-height: 1;
        }

        .h-score {
            position: absolute;
            bottom: 1px;
            right: 1px;
            font-size: 6px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 1px;
            border-radius: 1px;
            line-height: 1;
        }

        .btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent-light);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: var(--bg-panel);
            border-color: var(--border);
        }

        .tool-button {
            background: var(--bg-main);
            border: 1px solid var(--border);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .tool-button:hover {
            border-color: var(--accent);
        }

        .tool-button.active {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.2);
        }

        .heuristic-selector {
            background: var(--bg-main);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .heuristic-selector:hover {
            border-color: var(--accent);
        }

        .heuristic-selector.active {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.2);
        }

        .slider {
            appearance: none;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            height: 6px;
            border-radius: 3px;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            border: 1px solid var(--border);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col bg-[#101827] text-[#f3f4f6]">
    <!-- Header -->
    <header class="bg-[#1f2937] border-b border-[#374151] p-4">
        <h1 class="text-2xl font-bold text-center">A* Search Algorithm</h1>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col lg:flex-row gap-4 p-4">
        <!-- Left Panel - Controls -->
        <div class="lg:w-1/4 bg-[#1f2937] border border-[#374151] rounded-lg p-4 space-y-6">
            <!-- Tools -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Tools</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button class="tool-button active p-2 rounded text-sm" data-tool="start" onclick="selectTool('start')">
                        <i class="fas fa-play mr-1"></i>Start
                    </button>
                    <button class="tool-button p-2 rounded text-sm" data-tool="goal" onclick="selectTool('goal')">
                        <i class="fas fa-flag mr-1"></i>Goal
                    </button>
                    <button class="tool-button p-2 rounded text-sm" data-tool="wall" onclick="selectTool('wall')">
                        <i class="fas fa-square mr-1"></i>Wall
                    </button>
                    <button class="tool-button p-2 rounded text-sm" data-tool="eraser" onclick="selectTool('eraser')">
                        <i class="fas fa-eraser mr-1"></i>Erase
                    </button>
                </div>
            </div>

            <!-- Heuristic Function -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Heuristic</h3>
                <div class="space-y-2">
                    <div class="heuristic-selector active p-2 rounded text-sm" data-heuristic="manhattan" onclick="selectHeuristic('manhattan')">
                        Manhattan Distance
                    </div>
                    <div class="heuristic-selector p-2 rounded text-sm" data-heuristic="euclidean" onclick="selectHeuristic('euclidean')">
                        Euclidean Distance
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Controls</h3>
                <div class="space-y-2">
                    <button id="startSearch" onclick="startAstar()" class="btn w-full p-2 rounded">
                        Start A*
                    </button>
                    <button id="stepSearch" onclick="stepAstar()" class="btn w-full p-2 rounded" disabled>
                        Step Forward
                    </button>
                    <button onclick="resetGrid()" class="btn w-full p-2 rounded">
                        Reset
                    </button>
                    <button onclick="clearPath()" class="btn w-full p-2 rounded">
                        Clear Path
                    </button>
                </div>
            </div>

            <!-- Speed -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Speed</h3>
                <input type="range" id="speedSlider" class="slider w-full" min="1" max="10" value="5">
                <div class="flex justify-between text-sm text-[#9ca3af] mt-1">
                    <span>Slow</span>
                    <span>Fast</span>
                </div>
            </div>

            <!-- Options -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Options</h3>
                <label class="flex items-center text-sm">
                    <input type="checkbox" id="showScores" checked class="mr-2 accent-[#8b5cf6]">
                    <span>Show Scores</span>
                </label>
            </div>

            <!-- Statistics -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Statistics</h3>
                <div class="bg-[#101827] border border-[#374151] rounded p-3 space-y-2">
                    <div class="flex justify-between text-sm">
                        <span class="text-[#9ca3af]">Nodes Explored:</span>
                        <span id="nodesExplored">0</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span class="text-[#9ca3af]">Path Length:</span>
                        <span id="pathLength">0</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span class="text-[#9ca3af]">Path Cost:</span>
                        <span id="pathCost">-</span>
                    </div>
                    <div class="flex justify-between text-sm">
                        <span class="text-[#9ca3af]">Status:</span>
                        <span id="searchStatus">Ready</span>
                    </div>
                </div>
            </div>

            <!-- Legend -->
            <div>
                <h3 class="text-lg font-semibold mb-3">Legend</h3>
                <div class="space-y-2">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #10b981;"></div>
                        <span>Start</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ef4444;"></div>
                        <span>Goal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #374151;"></div>
                        <span>Wall</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #06d6a0;"></div>
                        <span>Open List</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8b5cf6;"></div>
                        <span>Closed List</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f59e0b;"></div>
                        <span>Path</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Center Panel - Grid Visualization -->
        <div class="lg:w-3/4 bg-[#1f2937] border border-[#374151] rounded-lg p-4">
            <div class="h-full flex flex-col">
                <h3 class="text-lg font-semibold mb-3">Grid Visualization</h3>
                <div class="flex-grow flex items-center justify-center overflow-auto">
                    <div class="bg-[#101827] border border-[#374151] rounded p-4">
                        <div id="grid" class="inline-block"></div>
                    </div>
                </div>
                
                <!-- Quick Instructions -->
                <div class="mt-4 text-sm text-[#9ca3af] text-center">
                    Click to place start/goal/walls • Drag to paint walls • Select tool from left panel
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-[#1f2937] border-t border-[#374151] p-4 mt-auto">
        <div class="flex justify-center space-x-6">
            <a href="https://www.linkedin.com/in/ashish-jangra/" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-linkedin fa-2x"></i>
            </a>
            <a href="https://github.com/AshishJangra27" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-github fa-2x"></i>
            </a>
            <a href="https://www.kaggle.com/ashishjangra27" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-kaggle fa-2x"></i>
            </a>
            <a href="https://huggingface.co/ashish-jangra" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
            </a>
            <a href="https://www.instagram.com/ashish_zangra/" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-instagram fa-2x"></i>
            </a>
        </div>
    </footer>

    <script>
        // Application state
        let grid = [];
        let gridSize = { rows: 20, cols: 30 };
        let startNode = null;
        let goalNode = null;
        let currentTool = 'start';
        let currentHeuristic = 'manhattan';
        let isSearching = false;
        let stepMode = false;
        let animationSpeed = 500;
        let showScores = true;

        // A* algorithm state
        let openList = [];
        let closedList = [];
        let currentNode = null;
        let pathFound = false;
        let searchStats = {
            nodesExplored: 0,
            pathLength: 0
        };

        // Cell types
        const CELL_TYPES = {
            EMPTY: 'empty',
            WALL: 'wall',
            START: 'start',
            GOAL: 'goal',
            OPEN: 'open',
            CLOSED: 'closed',
            PATH: 'path',
            CURRENT: 'current'
        };

        // Node class for A* algorithm
        class Node {
            constructor(row, col) {
                this.row = row;
                this.col = col;
                this.type = CELL_TYPES.EMPTY;
                this.g = Infinity;
                this.h = 0;
                this.f = Infinity;
                this.parent = null;
            }

            equals(other) {
                return this.row === other.row && this.col === other.col;
            }

            getNeighbors() {
                const neighbors = [];
                const directions = [
                    [-1, 0], [1, 0], [0, -1], [0, 1], // Cardinal directions
                    [-1, -1], [-1, 1], [1, -1], [1, 1] // Diagonal directions
                ];

                for (const [dRow, dCol] of directions) {
                    const newRow = this.row + dRow;
                    const newCol = this.col + dCol;

                    if (newRow >= 0 && newRow < gridSize.rows && 
                        newCol >= 0 && newCol < gridSize.cols &&
                        grid[newRow][newCol].type !== CELL_TYPES.WALL) {
                        neighbors.push(grid[newRow][newCol]);
                    }
                }

                return neighbors;
            }

            getMovementCost(neighbor) {
                const isDiagonal = Math.abs(this.row - neighbor.row) === 1 && 
                                 Math.abs(this.col - neighbor.col) === 1;
                return isDiagonal ? Math.sqrt(2) : 1;
            }
        }

        // Heuristic functions
        const heuristics = {
            manhattan: (node, goal) => {
                return Math.abs(node.row - goal.row) + Math.abs(node.col - goal.col);
            },
            euclidean: (node, goal) => {
                const dx = node.row - goal.row;
                const dy = node.col - goal.col;
                return Math.sqrt(dx * dx + dy * dy);
            }
        };

        // Initialize application
        function init() {
            setupEventListeners();
            initializeGrid();
            updateStats();
            setDefaultNodes();
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('speedSlider').addEventListener('input', updateSpeedFromSlider);
            document.getElementById('showScores').addEventListener('change', toggleScoreDisplay);
            
            let isMouseDown = false;
            document.addEventListener('mousedown', () => isMouseDown = true);
            document.addEventListener('mouseup', () => isMouseDown = false);
        }

        // Initialize grid
        function initializeGrid() {
            grid = [];
            for (let row = 0; row < gridSize.rows; row++) {
                grid[row] = [];
                for (let col = 0; col < gridSize.cols; col++) {
                    grid[row][col] = new Node(row, col);
                }
            }
            renderGrid();
        }

        // Render grid in DOM
        function renderGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            gridElement.style.display = 'grid';
            gridElement.style.gridTemplateColumns = `repeat(${gridSize.cols}, 25px)`;
            gridElement.style.gap = '1px';

            for (let row = 0; row < gridSize.rows; row++) {
                for (let col = 0; col < gridSize.cols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell cell-empty';
                    cell.id = `cell-${row}-${col}`;
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    cell.addEventListener('mouseenter', (e) => {
                        if (e.buttons === 1) handleCellClick(row, col);
                    });
                    
                    gridElement.appendChild(cell);
                }
            }
        }

        // Set default start and goal nodes
        function setDefaultNodes() {
            startNode = grid[2][2];
            startNode.type = CELL_TYPES.START;
            updateCellDisplay(startNode);

            goalNode = grid[gridSize.rows - 3][gridSize.cols - 3];
            goalNode.type = CELL_TYPES.GOAL;
            updateCellDisplay(goalNode);
        }

        // Handle cell clicks
        function handleCellClick(row, col) {
            if (isSearching) return;

            const node = grid[row][col];

            if (currentTool === 'start' && startNode) {
                startNode.type = CELL_TYPES.EMPTY;
                updateCellDisplay(startNode);
            } else if (currentTool === 'goal' && goalNode) {
                goalNode.type = CELL_TYPES.EMPTY;
                updateCellDisplay(goalNode);
            }

            switch (currentTool) {
                case 'start':
                    node.type = CELL_TYPES.START;
                    startNode = node;
                    break;
                case 'goal':
                    node.type = CELL_TYPES.GOAL;
                    goalNode = node;
                    break;
                case 'wall':
                    if (node !== startNode && node !== goalNode) {
                        node.type = CELL_TYPES.WALL;
                    }
                    break;
                case 'eraser':
                    if (node === startNode) startNode = null;
                    if (node === goalNode) goalNode = null;
                    node.type = CELL_TYPES.EMPTY;
                    break;
            }

            updateCellDisplay(node);
        }

        // Update cell display
        function updateCellDisplay(node) {
            const cell = document.getElementById(`cell-${node.row}-${node.col}`);
            cell.className = 'grid-cell';
            cell.innerHTML = '';

            switch (node.type) {
                case CELL_TYPES.EMPTY:
                    cell.classList.add('cell-empty');
                    break;
                case CELL_TYPES.WALL:
                    cell.classList.add('cell-wall');
                    break;
                case CELL_TYPES.START:
                    cell.classList.add('cell-start');
                    cell.innerHTML = '<i class="fas fa-play"></i>';
                    break;
                case CELL_TYPES.GOAL:
                    cell.classList.add('cell-goal');
                    cell.innerHTML = '<i class="fas fa-flag"></i>';
                    break;
                case CELL_TYPES.OPEN:
                    cell.classList.add('cell-open');
                    break;
                case CELL_TYPES.CLOSED:
                    cell.classList.add('cell-closed');
                    break;
                case CELL_TYPES.PATH:
                    cell.classList.add('cell-path');
                    break;
                case CELL_TYPES.CURRENT:
                    cell.classList.add('cell-current');
                    break;
            }

            // Add scores if enabled
            if (showScores && (node.type === CELL_TYPES.OPEN || node.type === CELL_TYPES.CLOSED || node.type === CELL_TYPES.CURRENT)) {
                if (node.f !== Infinity) {
                    cell.innerHTML += `<div class="f-score">${node.f.toFixed(1)}</div>`;
                }
                if (node.g !== Infinity) {
                    cell.innerHTML += `<div class="g-score">${node.g.toFixed(1)}</div>`;
                }
                if (node.h !== undefined) {
                    cell.innerHTML += `<div class="h-score">${node.h.toFixed(1)}</div>`;
                }
            }
        }

        // Tool selection
        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
        }

        // Heuristic selection
        function selectHeuristic(heuristic) {
            currentHeuristic = heuristic;
            document.querySelectorAll('.heuristic-selector').forEach(el => el.classList.remove('active'));
            document.querySelector(`[data-heuristic="${heuristic}"]`).classList.add('active');
        }

        // Start A* search
        async function startAstar() {
            if (!startNode || !goalNode) {
                alert('Please set both start and goal nodes!');
                return;
            }

            if (isSearching) return;

            clearPath();
            initializeAstar();
            isSearching = true;
            updateControls();
            updateSearchStatus('Searching...');

            await astarLoop();

            isSearching = false;
            updateControls();
        }

        // Initialize A* algorithm
        function initializeAstar() {
            openList = [];
            closedList = [];
            pathFound = false;
            searchStats = { nodesExplored: 0, pathLength: 0 };

            // Reset all nodes
            for (let row = 0; row < gridSize.rows; row++) {
                for (let col = 0; col < gridSize.cols; col++) {
                    const node = grid[row][col];
                    node.g = Infinity;
                    node.h = 0;
                    node.f = Infinity;
                    node.parent = null;
                }
            }

            startNode.g = 0;
            startNode.h = heuristics[currentHeuristic](startNode, goalNode);
            startNode.f = startNode.g + startNode.h;
            
            openList.push(startNode);
            updateStats();
        }

        // Main A* loop
        async function astarLoop() {
            while (openList.length > 0 && isSearching) {
                await astarStep();

                if (pathFound) {
                    await reconstructPath();
                    updateSearchStatus('Path found!');
                    break;
                }
            }

            if (openList.length === 0 && !pathFound) {
                updateSearchStatus('No path exists!');
            }
        }

        // Single A* step
        async function astarStep() {
            if (openList.length === 0) return false;

            // Find node with lowest f-score
            let bestIndex = 0;
            for (let i = 1; i < openList.length; i++) {
                if (openList[i].f < openList[bestIndex].f) {
                    bestIndex = i;
                }
            }

            currentNode = openList[bestIndex];

            // Highlight current node
            if (currentNode !== startNode && currentNode !== goalNode) {
                currentNode.type = CELL_TYPES.CURRENT;
                updateCellDisplay(currentNode);
            }

            await sleep(animationSpeed);

            // Move from open to closed list
            openList.splice(bestIndex, 1);
            closedList.push(currentNode);
            searchStats.nodesExplored++;

            if (currentNode !== startNode && currentNode !== goalNode) {
                currentNode.type = CELL_TYPES.CLOSED;
                updateCellDisplay(currentNode);
            }

            // Check if we reached the goal
            if (currentNode.equals(goalNode)) {
                pathFound = true;
                return true;
            }

            // Examine neighbors
            const neighbors = currentNode.getNeighbors();
            for (const neighbor of neighbors) {
                if (closedList.includes(neighbor)) continue;

                const tentativeG = currentNode.g + currentNode.getMovementCost(neighbor);

                if (!openList.includes(neighbor)) {
                    openList.push(neighbor);
                    if (neighbor !== startNode && neighbor !== goalNode) {
                        neighbor.type = CELL_TYPES.OPEN;
                        updateCellDisplay(neighbor);
                    }
                } else if (tentativeG >= neighbor.g) {
                    continue;
                }

                neighbor.parent = currentNode;
                neighbor.g = tentativeG;
                neighbor.h = heuristics[currentHeuristic](neighbor, goalNode);
                neighbor.f = neighbor.g + neighbor.h;

                if (neighbor !== startNode && neighbor !== goalNode) {
                    updateCellDisplay(neighbor);
                }
            }

            updateStats();
            await sleep(animationSpeed / 2);
            return true;
        }

        // Step-by-step A*
        async function stepAstar() {
            if (!isSearching && openList.length === 0) {
                if (!startNode || !goalNode) {
                    alert('Please set both start and goal nodes!');
                    return;
                }

                clearPath();
                initializeAstar();
                stepMode = true;
                updateControls();
                return;
            }

            if (openList.length > 0) {
                await astarStep();

                if (pathFound) {
                    await reconstructPath();
                    updateSearchStatus('Path found!');
                    stepMode = false;
                    updateControls();
                } else if (openList.length === 0) {
                    updateSearchStatus('No path exists!');
                    stepMode = false;
                    updateControls();
                }
            }
        }

        // Reconstruct path
        async function reconstructPath() {
            const path = [];
            let current = goalNode;

            while (current && current.parent) {
                path.unshift(current);
                current = current.parent;
            }
            path.unshift(startNode);

            searchStats.pathLength = path.length - 1;
            document.getElementById('pathCost').textContent = goalNode.g.toFixed(2);

            for (let i = 1; i < path.length - 1; i++) {
                path[i].type = CELL_TYPES.PATH;
                updateCellDisplay(path[i]);
                await sleep(animationSpeed / 4);
            }

            updateStats();
        }

        // Reset grid
        function resetGrid() {
            clearPath();
            startNode = null;
            goalNode = null;
            
            for (let row = 0; row < gridSize.rows; row++) {
                for (let col = 0; col < gridSize.cols; col++) {
                    grid[row][col].type = CELL_TYPES.EMPTY;
                    updateCellDisplay(grid[row][col]);
                }
            }

            setDefaultNodes();
            updateStats();
            updateSearchStatus('Ready');
        }

        // Clear path only
        function clearPath() {
            isSearching = false;
            stepMode = false;
            pathFound = false;
            currentNode = null;
            openList = [];
            closedList = [];
            searchStats = { nodesExplored: 0, pathLength: 0 };

            for (let row = 0; row < gridSize.rows; row++) {
                for (let col = 0; col < gridSize.cols; col++) {
                    const node = grid[row][col];
                    if (node.type === CELL_TYPES.OPEN || 
                        node.type === CELL_TYPES.CLOSED || 
                        node.type === CELL_TYPES.PATH ||
                        node.type === CELL_TYPES.CURRENT) {
                        node.type = CELL_TYPES.EMPTY;
                        updateCellDisplay(node);
                    }
                    
                    node.g = Infinity;
                    node.h = 0;
                    node.f = Infinity;
                    node.parent = null;
                }
            }

            updateStats();
            updateControls();
            updateSearchStatus('Ready');
            document.getElementById('pathCost').textContent = '-';
        }

        // Update controls
        function updateControls() {
            const startBtn = document.getElementById('startSearch');
            const stepBtn = document.getElementById('stepSearch');

            if (isSearching) {
                startBtn.disabled = true;
                stepBtn.disabled = true;
            } else if (stepMode) {
                startBtn.disabled = true;
                stepBtn.disabled = false;
            } else {
                startBtn.disabled = false;
                stepBtn.disabled = false;
            }
        }

        // Update statistics
        function updateStats() {
            document.getElementById('nodesExplored').textContent = searchStats.nodesExplored;
            document.getElementById('pathLength').textContent = searchStats.pathLength;
        }

        // Update search status
        function updateSearchStatus(status) {
            document.getElementById('searchStatus').textContent = status;
        }

        // Update animation speed
        function updateSpeedFromSlider() {
            const speed = document.getElementById('speedSlider').value;
            animationSpeed = 1100 - (speed * 100);
        }

        // Toggle score display
        function toggleScoreDisplay() {
            showScores = document.getElementById('showScores').checked;
            
            for (let row = 0; row < gridSize.rows; row++) {
                for (let col = 0; col < gridSize.cols; col++) {
                    const node = grid[row][col];
                    if (node.type === CELL_TYPES.OPEN || 
                        node.type === CELL_TYPES.CLOSED ||
                        node.type === CELL_TYPES.CURRENT) {
                        updateCellDisplay(node);
                    }
                }
            }
        }

        // Utility function for delays
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize the application
        init();
    </script>
</body>
</html>
