<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZT6JM33V5J"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-ZT6JM33V5J');
        </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom styles to ensure full height and apply fonts */
        body, html {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        /* Custom styles for better visual feedback on canvas */
        canvas {
            cursor: grab;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        /* Hide scrollbars for the main body */
        body {
            overflow: hidden;
        }
        /* Style for the context menu */
        #contextMenu {
            display: none;
            position: absolute;
            z-index: 1000;
        }
        /* Style for modals */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(17, 24, 39, 0.8); /* bg-gray-900 with opacity */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            margin: auto;
        }
        .hidden {
            display: none;
        }
        /* --- NEW FOOTER STYLES --- */
        .footer {
            background-color: #1f2937; /* bg-gray-800 */
            border-top: 1px solid #374151; /* border-gray-700 */
        }
        .footer-icon {
            transition: color 0.2s ease-in-out;
            color: #9ca3af; /* text-gray-400 */
        }
        .footer-icon:hover {
            color: #a78bfa; /* Lighter purple on hover */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <div id="app" class="flex flex-col h-screen">
        <!-- Header -->
        <header class="w-full p-3 bg-gray-800 shadow-xl">
            <h1 class="text-2xl font-bold text-center text-white">Neural Network Visualization</h1>
        </header>

        <!-- Main content area for visualization -->
        <main class="flex-grow w-full p-4 flex flex-col items-center justify-center bg-gray-900 overflow-hidden relative">
            <canvas id="neuralNetworkCanvas" class="w-full h-full block rounded-lg"></canvas>

            <!-- Calculate Parameters Button -->
            <button id="calculateBtn" class="absolute bottom-16 right-4 p-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-full shadow-lg transition-all duration-200 ease-in-out transform hover:scale-110 z-20" title="Calculate Parameters">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 7h6m-3 4v8m-1-8h2m-1 8h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </button>

            <!-- Center Canvas Button -->
            <button id="centerCanvasBtn" class="absolute bottom-4 right-4 p-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition-all duration-200 ease-in-out transform hover:scale-110 z-20" title="Center Canvas">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 1v4m0 0h-4m4 0l-5-5" />
                </svg>
            </button>
        </main>

        <footer class="footer w-full py-8 bg-panel-backgrounds border-t border-borders">
        <div class="container mx-auto px-6 text-center text-gray-400">
            <div class="flex justify-center items-center space-x-6 mb-4">
                <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank" rel="noopener noreferrer" class="footer-icon">
                    <i class="fab fa-linkedin fa-2x"></i>
                </a>
                <a href="https://github.com/AshishJangra27" target="_blank" rel="noopener noreferrer" class="footer-icon">
                    <i class="fab fa-github fa-2x"></i>
                </a>
                 <a href="https://www.kaggle.com/ashishjangra27" target="_blank" rel="noopener noreferrer" class="footer-icon">
                    <i class="fab fa-kaggle fa-2x"></i>
                </a>
                <a href="https://huggingface.co/ashish-jangra" target="_blank" rel="noopener noreferrer" class="footer-icon">
                     <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="inline-block">
                        <path d="M20.24,12.2a8.24,8.24,0,1,1-16.48,0a8.24,8.24,0,0,1,16.48,0Z" fill="currentColor"></path>
                        <path d="M15.42,16.2c.18-.42.24-.84.18-1.26a4.55,4.55,0,0,0-.54-1.5,4.55,4.55,0,0,0-1.5-.54c-.42-.06-.84.06-1.26.18a4.55,4.55,0,0,0-1.5.54,4.55,4.55,0,0,0-.54,1.5c-.06.42.06.84.18,1.26a4.55,4.55,0,0,0,.54,1.5,4.55,4.55,0,0,0,1.5.54c.42.06.84,0,1.26-.18a4.55,4.55,0,0,0,1.5-.54,4.55,4.55,0,0,0,.54-1.5Z" fill="#101827"></path>
                        <path d="M10.26,10.26a1.44,1.44,0,1,1-2.88,0,1.44,1.44,0,0,1,2.88,0" fill="#101827"></path>
                        <path d="M16.62,10.26a1.44,1.44,0,1,1-2.88,0,1.44,1.44,0,0,1,2.88,0" fill="#101827"></path>
                    </svg>
                </a>
                 <a href="https://www.instagram.com/ashish_zangra/" target="_blank" rel="noopener noreferrer" class="footer-icon">
                    <i class="fab fa-instagram fa-2x"></i>
                </a>
            </div>
            <p>&copy; 2024 vizlearn. All Rights Reserved.</p>
        </div>
    </footer>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="bg-gray-700 rounded-md shadow-lg p-2 text-sm text-white">
        <button id="ctxAddNeuron" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md">Add Neuron</button>
        <button id="ctxRemoveNeuron" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md text-red-400">Remove Neuron</button>
        <div id="ctxSeparator1" class="hidden border-t border-gray-600 my-1"></div>
        <button id="ctxEditFeatures" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md">Edit Features</button>
        <button id="ctxEditLabels" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md">Edit Labels</button>
        <button id="ctxAddLayer" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md">Add Layer After</button>
        <button id="ctxRemoveLayer" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md text-red-400">Remove Layer</button>
        <button id="ctxEditNeurons" class="hidden w-full text-left px-3 py-1 hover:bg-gray-600 rounded-md">Edit Neurons (Layer)</button>
    </div>

    <!-- Edit Modal -->
    <div id="editNeuronModal" class="modal hidden">
        <div class="modal-content bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700">
            <h3 id="editModalTitle" class="text-xl font-bold mb-4 text-blue-400">Edit</h3>
            <label id="editModalLabel" for="edit-neuron-count" class="block text-gray-300 mb-2">Value:</label>
            <input type="number" id="edit-neuron-count" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 mb-3" min="1" max="1000" required>
            <p id="editNeuronError" class="text-red-500 text-sm mb-3 hidden"></p>
            <div class="flex justify-end gap-3">
                <button id="cancelEditBtn" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md text-white transition-colors">Cancel</button>
                <button id="saveEditBtn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white transition-colors">Save</button>
            </div>
        </div>
    </div>

    <!-- Calculation Result Modal -->
    <div id="calculationResultModal" class="modal hidden">
        <div class="modal-content bg-gray-800 p-6 rounded-lg shadow-xl border border-gray-700 text-center max-w-3xl w-full">
            <h3 class="text-xl font-bold mb-4 text-blue-400">Network Parameters</h3>
            <div class="text-gray-100 text-left mb-6 overflow-x-auto">
                <table class="w-full table-auto border-collapse">
                    <thead id="calc-table-head">
                        <tr class="bg-gray-700">
                            <th class="px-4 py-2 border border-gray-600 text-white">From Layer</th>
                            <th class="px-4 py-2 border border-gray-600 text-white">To Layer</th>
                            <th class="px-4 py-2 border border-gray-600 text-white">Weights Calculation</th>
                            <th class="px-4 py-2 border border-gray-600 text-white">Biases</th>
                            <th class="px-4 py-2 border border-gray-600 text-white">Layer Total</th>
                        </tr>
                    </thead>
                    <tbody id="calc-table-body">
                        <!-- Rows will be injected by JS -->
                    </tbody>
                </table>
            </div>
            <p id="totalWeightsResult" class="mt-4 text-lg font-bold">Total Weights: 0</p>
            <p id="totalBiasesResult" class="mt-2 text-lg font-bold">Total Biases: 0</p>
            <p id="totalParamsResult" class="mt-2 text-lg font-bold">Total Parameters: 0</p>
            <button id="closeCalcModalBtn" class="px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded-md text-white transition-colors mt-6">Close</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const canvas = document.getElementById('neuralNetworkCanvas');
            const ctx = canvas.getContext('2d');
            const centerCanvasBtn = document.getElementById('centerCanvasBtn');
            const calculateBtn = document.getElementById('calculateBtn');
            
            // Context Menu
            const contextMenu = document.getElementById('contextMenu');
            const ctxAddLayer = document.getElementById('ctxAddLayer');
            const ctxRemoveLayer = document.getElementById('ctxRemoveLayer');
            const ctxEditNeurons = document.getElementById('ctxEditNeurons');
            const ctxEditFeatures = document.getElementById('ctxEditFeatures');
            const ctxEditLabels = document.getElementById('ctxEditLabels');
            const ctxAddNeuron = document.getElementById('ctxAddNeuron');
            const ctxRemoveNeuron = document.getElementById('ctxRemoveNeuron');
            const ctxSeparator1 = document.getElementById('ctxSeparator1');

            // Edit Modal
            const editNeuronModal = document.getElementById('editNeuronModal');
            const editModalTitle = document.getElementById('editModalTitle');
            const editModalLabel = document.getElementById('editModalLabel');
            const editNeuronInput = document.getElementById('edit-neuron-count');
            const editNeuronError = document.getElementById('editNeuronError');
            const cancelEditBtn = document.getElementById('cancelEditBtn');
            const saveEditBtn = document.getElementById('saveEditBtn');

            // Calculation Modal
            const calculationResultModal = document.getElementById('calculationResultModal');
            const calcTableBody = document.getElementById('calc-table-body');
            const totalParamsResult = document.getElementById('totalParamsResult');
            const totalWeightsResult = document.getElementById('totalWeightsResult');
            const totalBiasesResult = document.getElementById('totalBiasesResult');
            const closeCalcModalBtn = document.getElementById('closeCalcModalBtn');

            // --- State Variables ---
            let numFeatures = 4;
            let hiddenLayerNeuronCounts = [8, 8, 8];
            let numLabels = 3;

            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;

            let selectedNeuron = null; // { layerIndex, neuronIndex }
            let hoveredNeuron = null; // { layerIndex, neuronIndex }
            let selectedConnection = null; // { fromLayer, fromNeuron, toLayer, toNeuron }
            let highlightedPathNeurons = new Map(); // "layer_neuron" -> distance
            
            let neuronPositions = []; // Stores {x, y} for each neuron
            let currentNeuronRadius = 35;

            let contextMenuTarget = { layer: -1, neuron: -1 };

            // --- Constants ---
            const NEURON_BASE_SPACING_FACTOR = 1.5;
            const LAYER_SPACING_MULTIPLIER = 6;

            // --- Core Drawing Logic ---
            function drawNetwork() {
                if (!ctx) return;

                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                
                ctx.scale(dpr, dpr);

                // Clear canvas with background color
                ctx.fillStyle = '#111827'; // bg-gray-900
                ctx.fillRect(0, 0, rect.width, rect.height);

                ctx.save();
                // Apply pan and zoom
                ctx.translate(translateX, translateY);
                ctx.scale(scale, scale);

                // --- Define Colors ---
                const neuronColorInputOutputDefault = '#3366CC';
                const neuronColorHiddenDefault = '#111827';
                const neuronHighlightColor = 'rgba(0, 191, 255, 0.7)';
                const connectionHighlightColor = 'rgba(0, 191, 255, 0.7)';
                const layerHoverFillColor = 'rgba(0, 191, 255, 0.15)';
                const neuronHoverBorderColor = '#FFFFFF';
                const connectionColor = 'rgba(173, 216, 230, 0.25)';
                const neuronBorderColor = 'rgba(255, 255, 255, 0.3)';
                const textColor = '#E0E0E0';

                // --- Calculate Layout ---
                const layers = [numFeatures, ...hiddenLayerNeuronCounts, numLabels];
                const numLayers = layers.length;
                const maxNeuronsInAnyLayer = Math.max(...layers, 1);
                
                const layerSpacing = currentNeuronRadius * NEURON_BASE_SPACING_FACTOR * LAYER_SPACING_MULTIPLIER;
                const neuronSpacingY = currentNeuronRadius * NEURON_BASE_SPACING_FACTOR * 2;

                const totalContentWidth = (numLayers > 1 ? (numLayers - 1) * layerSpacing : 0) + (2 * currentNeuronRadius);
                const totalContentHeight = maxNeuronsInAnyLayer * (2 * currentNeuronRadius + neuronSpacingY) - neuronSpacingY;
                
                // --- Calculate and Store Neuron Positions (relative to a 0,0 origin) ---
                neuronPositions = [];
                layers.forEach((numNeuronsInLayer, layerIndex) => {
                    const currentLayerPositions = [];
                    const layerX = layerIndex * layerSpacing;
                    const currentLayerHeight = numNeuronsInLayer * (2 * currentNeuronRadius + neuronSpacingY) - neuronSpacingY;
                    const layerVerticalOffset = (totalContentHeight - currentLayerHeight) / 2;

                    for (let i = 0; i < numNeuronsInLayer; i++) {
                        const y = layerVerticalOffset + i * (2 * currentNeuronRadius + neuronSpacingY);
                        const x = layerX;
                        currentLayerPositions.push({ x: x + currentNeuronRadius, y: y + currentNeuronRadius });
                    }
                    neuronPositions.push(currentLayerPositions);
                });

                // --- Phase 1: Draw Non-Highlighted Connections ---
                ctx.beginPath();
                ctx.strokeStyle = connectionColor;
                ctx.lineWidth = 0.8 / scale; // Keep line width consistent when zooming
                for (let i = 0; i < numLayers - 1; i++) {
                    neuronPositions[i].forEach((neuron1, n1Index) => {
                        neuronPositions[i + 1].forEach((neuron2, n2Index) => {
                            const nextNeuronKey = `${i + 1}_${n2Index}`;
                            const isPartOfPath = highlightedPathNeurons.has(nextNeuronKey);
                            const isThisConnectionSelected = selectedConnection &&
                                selectedConnection.fromLayer === i && selectedConnection.fromNeuron === n1Index &&
                                selectedConnection.toLayer === i + 1 && selectedConnection.toNeuron === n2Index;

                            if (!isPartOfPath && !isThisConnectionSelected) {
                                ctx.moveTo(neuron1.x, neuron1.y);
                                ctx.lineTo(neuron2.x, neuron2.y);
                            }
                        });
                    });
                }
                ctx.stroke();
                ctx.closePath();

                // --- Phase 2: Draw Neurons and Labels ---
                layers.forEach((numNeurons, layerIndex) => {
                    neuronPositions[layerIndex].forEach((neuron, i) => {
                        const neuronKey = `${layerIndex}_${i}`;
                        const distance = highlightedPathNeurons.get(neuronKey);
                        const isPartOfPath = distance !== undefined;

                        const isSelected = selectedNeuron && selectedNeuron.layerIndex === layerIndex && selectedNeuron.neuronIndex === i;
                        const isHovered = hoveredNeuron && hoveredNeuron.layerIndex === layerIndex && hoveredNeuron.neuronIndex === i;
                        
                        ctx.beginPath();
                        ctx.arc(neuron.x, neuron.y, currentNeuronRadius, 0, Math.PI * 2);

                        // Fill color logic
                        if (isSelected) {
                            ctx.fillStyle = neuronHighlightColor;
                        } else if (isPartOfPath) {
                            const alpha = Math.max(0.2, 0.7 - (distance / (numLayers - 1 || 1)) * 0.5);
                            ctx.fillStyle = `rgba(0, 191, 255, ${alpha})`;
                        } else {
                            let baseColor = (layerIndex === 0 || layerIndex === numLayers - 1) ? neuronColorInputOutputDefault : neuronColorHiddenDefault;
                            if (isHovered) {
                                ctx.fillStyle = neuronColorInputOutputDefault;
                            } else {
                                ctx.fillStyle = baseColor;
                            }
                        }
                        ctx.fill();

                        // Border color logic
                        const baseLineWidth = 1;
                        if (isSelected) {
                            ctx.strokeStyle = connectionHighlightColor;
                            ctx.lineWidth = (baseLineWidth + 1) / scale;
                        } else if (isHovered) {
                            ctx.strokeStyle = neuronHoverBorderColor;
                            ctx.lineWidth = (baseLineWidth + 0.5) / scale;
                        } else if (isPartOfPath) {
                            ctx.strokeStyle = connectionHighlightColor;
                            ctx.lineWidth = (baseLineWidth + 0.5) / scale;
                        } else {
                            ctx.strokeStyle = neuronBorderColor;
                            ctx.lineWidth = baseLineWidth / scale;
                        }
                        ctx.stroke();
                        ctx.closePath();

                        // Text label
                        ctx.fillStyle = textColor;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        let label = '';
                        if (layerIndex === 0) label = `input ${i + 1}`;
                        else if (layerIndex === numLayers - 1) label = `output ${i + 1}`;
                        else label = `h${layerIndex} n${i + 1}`;
                        
                        // Dynamic font size
                        let fontSize = currentNeuronRadius * 0.8;
                        ctx.font = `${fontSize}px 'Roboto Mono', monospace`;
                        let textWidth = ctx.measureText(label).width;
                        const maxTextWidth = currentNeuronRadius * 2 * 0.8;
                        while (textWidth > maxTextWidth && fontSize > 5) {
                            fontSize -= 0.5;
                            ctx.font = `${fontSize}px 'Roboto Mono', monospace`;
                            textWidth = ctx.measureText(label).width;
                        }
                        ctx.fillText(label, neuron.x, neuron.y);
                    });
                });

                // --- Phase 3: Draw Highlighted Connections (Path) ---
                ctx.beginPath();
                ctx.lineWidth = 1.5 / scale;
                for (let i = 0; i < numLayers - 1; i++) {
                    neuronPositions[i].forEach((neuron1) => {
                        neuronPositions[i+1].forEach((neuron2, n2Index) => {
                            const nextNeuronKey = `${i + 1}_${n2Index}`;
                            const distance = highlightedPathNeurons.get(nextNeuronKey);
                            if (distance !== undefined) {
                                const alpha = Math.max(0.2, 0.7 - (distance / (numLayers - 1 || 1)) * 0.5);
                                ctx.strokeStyle = `rgba(0, 191, 255, ${alpha})`;
                                ctx.moveTo(neuron1.x, neuron1.y);
                                ctx.lineTo(neuron2.x, neuron2.y);
                            }
                        });
                    });
                }
                ctx.stroke();
                ctx.closePath();
                
                // --- Phase 4: Draw Specifically Selected Connection ---
                if (selectedConnection) {
                    const fromNeuron = neuronPositions[selectedConnection.fromLayer][selectedConnection.fromNeuron];
                    const toNeuron = neuronPositions[selectedConnection.toLayer][selectedConnection.toNeuron];
                    if (fromNeuron && toNeuron) {
                        ctx.beginPath();
                        ctx.strokeStyle = connectionHighlightColor;
                        ctx.lineWidth = 2.5 / scale;
                        ctx.moveTo(fromNeuron.x, fromNeuron.y);
                        ctx.lineTo(toNeuron.x, toNeuron.y);
                        ctx.stroke();
                        ctx.closePath();
                    }
                }

                ctx.restore();
            }

            // --- Helper Functions ---
            function updateNeuronRadius() {
                const layers = [numFeatures, ...hiddenLayerNeuronCounts, numLabels];
                const numLayers = layers.length;
                const maxNeuronsConsidered = Math.max(...layers, 1);
                const baseNeuronRadius = 35;
                const densityFactor = Math.sqrt(maxNeuronsConsidered * numLayers) / 10;
                currentNeuronRadius = Math.max(15, baseNeuronRadius / (1 + densityFactor * 0.5));
            }

            function resetView() {
                updateNeuronRadius();
                const layers = [numFeatures, ...hiddenLayerNeuronCounts, numLabels];
                const numLayers = layers.length;
                const maxNeuronsInAnyLayer = Math.max(...layers, 1);
                
                const layerSpacing = currentNeuronRadius * NEURON_BASE_SPACING_FACTOR * LAYER_SPACING_MULTIPLIER;
                const neuronSpacingY = currentNeuronRadius * NEURON_BASE_SPACING_FACTOR * 2;

                const totalContentWidth = (numLayers > 1 ? (numLayers - 1) * layerSpacing : 0) + (2 * currentNeuronRadius);
                const totalContentHeight = maxNeuronsInAnyLayer * (2 * currentNeuronRadius + neuronSpacingY) - neuronSpacingY;

                const canvasWidth = canvas.getBoundingClientRect().width;
                const canvasHeight = canvas.getBoundingClientRect().height;
                const minPadding = 30;

                const scaleX = (canvasWidth - 2 * minPadding) / totalContentWidth;
                const scaleY = (canvasHeight - 2 * minPadding) / totalContentHeight;
                
                scale = Math.max(0.1, Math.min(2, Math.min(scaleX, scaleY)));
                
                translateX = (canvasWidth - totalContentWidth * scale) / 2;
                translateY = (canvasHeight - totalContentHeight * scale) / 2;
                
                selectedNeuron = null;
                hoveredNeuron = null;
                selectedConnection = null;
                highlightedPathNeurons.clear();
                
                drawNetwork();
            }
            
            function updateAndRedraw() {
                resetView();
            }

            function calculateHighlightedPath() {
                highlightedPathNeurons.clear();
                if (!selectedNeuron) return;

                const queue = [{ neuron: selectedNeuron, distance: 0 }];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const { neuron, distance } = queue.shift();
                    const neuronKey = `${neuron.layerIndex}_${neuron.neuronIndex}`;
                    if (visited.has(neuronKey)) continue;
                    visited.add(neuronKey);

                    highlightedPathNeurons.set(neuronKey, selectedNeuron.layerIndex - neuron.layerIndex);

                    if (neuron.layerIndex > 0) {
                        const prevLayerIndex = neuron.layerIndex - 1;
                        const prevLayerNeurons = neuronPositions[prevLayerIndex];
                        if (prevLayerNeurons) {
                            prevLayerNeurons.forEach((_, prevNeuronIndex) => {
                                const prevNeuron = { layerIndex: prevLayerIndex, neuronIndex: prevNeuronIndex };
                                const prevNeuronKey = `${prevNeuron.layerIndex}_${prevNeuron.neuronIndex}`;
                                if (!visited.has(prevNeuronKey)) {
                                    queue.push({ neuron: prevNeuron, distance: distance + 1 });
                                }
                            });
                        }
                    }
                }
            }

            function isPointNearLine(px, py, x1, y1, x2, y2, tolerance) {
                const L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                if (L2 === 0) {
                    return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2)) <= tolerance;
                }
                const t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
                let closestX, closestY;
                if (t < 0) {
                    [closestX, closestY] = [x1, y1];
                } else if (t > 1) {
                    [closestX, closestY] = [x2, y2];
                } else {
                    [closestX, closestY] = [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
                }
                const distance = Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
                return distance <= tolerance;
            }

            // --- Event Handlers ---
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.classList.add('grabbing');
                contextMenu.style.display = 'none';
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    translateX += dx;
                    translateY += dy;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    drawNetwork();
                } else {
                    // Hover detection
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const transformedX = (mouseX - translateX) / scale;
                    const transformedY = (mouseY - translateY) / scale;

                    let currentHovered = null;
                    if (neuronPositions.length > 0) {
                        for (let layerIndex = 0; layerIndex < neuronPositions.length; layerIndex++) {
                            for (let neuronIndex = 0; neuronIndex < neuronPositions[layerIndex].length; neuronIndex++) {
                                const neuron = neuronPositions[layerIndex][neuronIndex];
                                const distance = Math.sqrt(Math.pow(transformedX - neuron.x, 2) + Math.pow(transformedY - neuron.y, 2));
                                if (distance <= currentNeuronRadius) {
                                    currentHovered = { layerIndex, neuronIndex };
                                    break;
                                }
                            }
                            if (currentHovered) break;
                        }
                    }
                    if (JSON.stringify(hoveredNeuron) !== JSON.stringify(currentHovered)) {
                        hoveredNeuron = currentHovered;
                        drawNetwork();
                    }
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.classList.remove('grabbing');
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                hoveredNeuron = null;
                canvas.classList.remove('grabbing');
                drawNetwork();
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const zoomFactor = 1.1;
                const newScale = e.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor;
                const clampedScale = Math.max(0.1, Math.min(5, newScale));
                
                const newTranslateX = mouseX - (mouseX - translateX) * (clampedScale / scale);
                const newTranslateY = mouseY - (mouseY - translateY) * (clampedScale / scale);

                scale = clampedScale;
                translateX = newTranslateX;
                translateY = newTranslateY;
                
                drawNetwork();
            });

            canvas.addEventListener('click', (e) => {
                if (isDragging) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const transformedX = (mouseX - translateX) / scale;
                const transformedY = (mouseY - translateY) / scale;

                let clickedNeuron = null;
                for (let layerIndex = 0; layerIndex < neuronPositions.length; layerIndex++) {
                    for (let neuronIndex = 0; neuronIndex < neuronPositions[layerIndex].length; neuronIndex++) {
                        const neuron = neuronPositions[layerIndex][neuronIndex];
                        const distance = Math.sqrt(Math.pow(transformedX - neuron.x, 2) + Math.pow(transformedY - neuron.y, 2));
                        if (distance <= currentNeuronRadius) {
                            clickedNeuron = { layerIndex, neuronIndex };
                            break;
                        }
                    }
                    if (clickedNeuron) break;
                }

                if (clickedNeuron) {
                    selectedConnection = null;
                    if (selectedNeuron && selectedNeuron.layerIndex === clickedNeuron.layerIndex && selectedNeuron.neuronIndex === clickedNeuron.neuronIndex) {
                        selectedNeuron = null;
                    } else {
                        selectedNeuron = clickedNeuron;
                    }
                } else {
                    let clickedConnection = null;
                    for (let i = 0; i < neuronPositions.length - 1; i++) {
                        for (let j = 0; j < neuronPositions[i].length; j++) {
                            for (let k = 0; k < neuronPositions[i+1].length; k++) {
                                const n1 = neuronPositions[i][j];
                                const n2 = neuronPositions[i+1][k];
                                if (isPointNearLine(transformedX, transformedY, n1.x, n1.y, n2.x, n2.y, 5 / scale)) {
                                    clickedConnection = { fromLayer: i, fromNeuron: j, toLayer: i + 1, toNeuron: k };
                                    break;
                                }
                            }
                            if (clickedConnection) break;
                        }
                        if (clickedConnection) break;
                    }

                    if (clickedConnection) {
                        selectedNeuron = null;
                        if (selectedConnection && selectedConnection.fromLayer === clickedConnection.fromLayer && selectedConnection.fromNeuron === clickedConnection.fromNeuron && selectedConnection.toLayer === clickedConnection.toLayer && selectedConnection.toNeuron === clickedConnection.toNeuron) {
                            selectedConnection = null;
                        } else {
                            selectedConnection = clickedConnection;
                        }
                    } else {
                        selectedNeuron = null;
                        selectedConnection = null;
                    }
                }
                calculateHighlightedPath();
                drawNetwork();
            });

            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const transformedX = (mouseX - translateX) / scale;
                const transformedY = (mouseY - translateY) / scale;
                
                const layers = [numFeatures, ...hiddenLayerNeuronCounts, numLabels];
                const numLayers = layers.length;

                // Priority 1: Check for neuron click
                let clickedNeuron = null;
                for (let layerIndex = 0; layerIndex < neuronPositions.length; layerIndex++) {
                    for (let neuronIndex = 0; neuronIndex < neuronPositions[layerIndex].length; neuronIndex++) {
                        const neuron = neuronPositions[layerIndex][neuronIndex];
                        const distance = Math.sqrt(Math.pow(transformedX - neuron.x, 2) + Math.pow(transformedY - neuron.y, 2));
                        if (distance <= currentNeuronRadius) {
                            clickedNeuron = { layer: layerIndex, neuron: neuronIndex };
                            break;
                        }
                    }
                    if (clickedNeuron) break;
                }

                // Hide all buttons and separators initially
                [ctxAddLayer, ctxRemoveLayer, ctxEditNeurons, ctxEditFeatures, ctxEditLabels, ctxAddNeuron, ctxRemoveNeuron, ctxSeparator1].forEach(el => el.classList.add('hidden'));

                if (clickedNeuron) {
                    contextMenuTarget = clickedNeuron;
                    const layerSize = layers[clickedNeuron.layer];
                    if (layerSize > 1) {
                         ctxRemoveNeuron.classList.remove('hidden');
                    }
                } else {
                    // Priority 2: Check for layer click (empty space)
                    const layerSpacing = currentNeuronRadius * NEURON_BASE_SPACING_FACTOR * LAYER_SPACING_MULTIPLIER;
                    
                    let clickedLayerIndex = -1;
                    for (let i = 0; i < numLayers; i++) {
                        const layerStartX = i * layerSpacing;
                        const layerEndX = layerStartX + currentNeuronRadius * 2;
                        // A wider hit area for the layer itself
                        const hitAreaStartX = layerStartX - layerSpacing / 4;
                        const hitAreaEndX = layerEndX + layerSpacing / 4;

                        if (transformedX >= hitAreaStartX && transformedX <= hitAreaEndX) {
                            clickedLayerIndex = i;
                            break;
                        }
                    }

                    if (clickedLayerIndex !== -1) {
                        contextMenuTarget = { layer: clickedLayerIndex, neuron: -1 };
                        ctxAddNeuron.classList.remove('hidden');
                        ctxSeparator1.classList.remove('hidden');

                        if (clickedLayerIndex === 0) { // Input Layer
                            ctxEditFeatures.classList.remove('hidden');
                            ctxAddLayer.classList.remove('hidden');
                        } else if (clickedLayerIndex === numLayers - 1) { // Output Layer
                            ctxEditLabels.classList.remove('hidden');
                        } else { // Hidden Layer
                            ctxAddLayer.classList.remove('hidden');
                            ctxRemoveLayer.classList.remove('hidden');
                            ctxEditNeurons.classList.remove('hidden');
                        }
                    } else {
                        return; // No valid target, don't show menu
                    }
                }
                
                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.style.display = 'block';
            });
            
            // --- Context Menu and Modal Logic ---
            ctxAddNeuron.addEventListener('click', () => {
                const layerIndex = contextMenuTarget.layer;
                if (layerIndex === 0) {
                    numFeatures++;
                } else if (layerIndex === [numFeatures, ...hiddenLayerNeuronCounts, numLabels].length - 1) {
                    numLabels++;
                } else {
                    hiddenLayerNeuronCounts[layerIndex - 1]++;
                }
                contextMenu.style.display = 'none';
                updateAndRedraw();
            });

            ctxRemoveNeuron.addEventListener('click', () => {
                const { layer } = contextMenuTarget;
                if (layer === 0 && numFeatures > 1) {
                    numFeatures--;
                } else if (layer === [numFeatures, ...hiddenLayerNeuronCounts, numLabels].length - 1 && numLabels > 1) {
                    numLabels--;
                } else if (layer > 0 && hiddenLayerNeuronCounts[layer - 1] > 1) {
                    hiddenLayerNeuronCounts[layer - 1]--;
                }
                contextMenu.style.display = 'none';
                updateAndRedraw();
            });

            ctxAddLayer.addEventListener('click', () => {
                const insertIndex = contextMenuTarget.layer;
                hiddenLayerNeuronCounts.splice(insertIndex, 0, 8);
                contextMenu.style.display = 'none';
                updateAndRedraw();
            });

            ctxRemoveLayer.addEventListener('click', () => {
                if (hiddenLayerNeuronCounts.length > 0) {
                    hiddenLayerNeuronCounts.splice(contextMenuTarget.layer - 1, 1);
                }
                contextMenu.style.display = 'none';
                updateAndRedraw();
            });

            function showEditModal(type) {
                const layerIndex = contextMenuTarget.layer;
                if (type === 'features') {
                    editModalTitle.textContent = 'Edit Input Features';
                    editModalLabel.textContent = 'Number of Features:';
                    editNeuronInput.value = numFeatures;
                } else if (type === 'labels') {
                    editModalTitle.textContent = 'Edit Output Labels';
                    editModalLabel.textContent = 'Number of Labels:';
                    editNeuronInput.value = numLabels;
                } else { // 'neurons'
                    editModalTitle.textContent = 'Edit Neuron Count';
                    editModalLabel.textContent = 'Number of Neurons:';
                    editNeuronInput.value = hiddenLayerNeuronCounts[layerIndex - 1];
                }
                editNeuronError.classList.add('hidden');
                editNeuronModal.style.display = 'flex';
                contextMenu.style.display = 'none';
            }

            ctxEditFeatures.addEventListener('click', () => showEditModal('features'));
            ctxEditLabels.addEventListener('click', () => showEditModal('labels'));
            ctxEditNeurons.addEventListener('click', () => showEditModal('neurons'));
            
            // Edit Modal Handlers
            cancelEditBtn.addEventListener('click', () => editNeuronModal.style.display = 'none');
            saveEditBtn.addEventListener('click', () => {
                const val = parseInt(editNeuronInput.value);
                if (isNaN(val) || val < 1) {
                    editNeuronError.textContent = 'Value must be a positive number.';
                    editNeuronError.classList.remove('hidden');
                    return;
                }
                if (val > 1000) {
                    editNeuronError.textContent = 'Maximum value is 1000.';
                    editNeuronError.classList.remove('hidden');
                    return;
                }
                
                const layers = [numFeatures, ...hiddenLayerNeuronCounts, numLabels];
                const numLayers = layers.length;
                const layerIndex = contextMenuTarget.layer;

                if (layerIndex === 0) {
                    numFeatures = val;
                } else if (layerIndex === numLayers - 1) {
                    numLabels = val;
                } else {
                    hiddenLayerNeuronCounts[layerIndex - 1] = val;
                }

                editNeuronModal.style.display = 'none';
                updateAndRedraw();
            });

            // Calculate Modal Handlers
            calculateBtn.addEventListener('click', () => {
                const layerSizes = [numFeatures, ...hiddenLayerNeuronCounts, numLabels];
                let totalParameters = 0;
                let totalWeights = 0;
                let totalBiases = 0;
                let detailsHtml = '';

                for (let i = 0; i < layerSizes.length - 1; i++) {
                    const currentSize = layerSizes[i];
                    const nextSize = layerSizes[i + 1];
                    const weights = currentSize * nextSize;
                    const biases = nextSize;
                    const layerTotal = weights + biases;
                    totalParameters += layerTotal;
                    totalWeights += weights;
                    totalBiases += biases;

                    const fromLayerName = i === 0 ? `Input (${currentSize})` : `Hidden ${i} (${currentSize})`;
                    const toLayerName = (i === layerSizes.length - 2) ? `Output (${nextSize})` : `Hidden ${i + 1} (${nextSize})`;

                    detailsHtml += `
                        <tr class="odd:bg-gray-800 even:bg-gray-700">
                            <td class="px-4 py-2 border border-gray-600 text-sm">${fromLayerName}</td>
                            <td class="px-4 py-2 border border-gray-600 text-sm">${toLayerName}</td>
                            <td class="px-4 py-2 border border-gray-600 text-sm">${nextSize.toLocaleString()} * ${currentSize.toLocaleString()} = ${weights.toLocaleString()}</td>
                            <td class="px-4 py-2 border border-gray-600 text-sm">${biases.toLocaleString()}</td>
                            <td class="px-4 py-2 border border-gray-600 text-sm font-semibold">${layerTotal.toLocaleString()}</td>
                        </tr>`;
                }
                calcTableBody.innerHTML = detailsHtml;
                totalWeightsResult.textContent = `Total Weights: ${totalWeights.toLocaleString()}`;
                totalBiasesResult.textContent = `Total Biases: ${totalBiases.toLocaleString()}`;
                totalParamsResult.textContent = `Total Parameters: ${totalParameters.toLocaleString()}`;
                calculationResultModal.style.display = 'flex';
            });
            closeCalcModalBtn.addEventListener('click', () => calculationResultModal.style.display = 'none');


            // --- Global Listeners ---
            window.addEventListener('resize', updateAndRedraw);
            document.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.style.display = 'none';
                }
            });

            // --- Initial Setup ---
            centerCanvasBtn.addEventListener('click', resetView);
            updateAndRedraw();
        });
    </script>
</body>
</html>
