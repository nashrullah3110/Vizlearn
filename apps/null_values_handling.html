<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Null Values Handling Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }
        .data-cell {
            transition: all 0.3s ease;
        }
        .data-cell.null {
            background-color: #dc2626;
            color: #fef2f2;
        }
        .data-cell.filled {
            background-color: #059669;
            color: #f0fdf4;
        }
        .data-cell.imputed {
            background-color: #d97706;
            color: #fefbeb;
        }
        .strategy-button.active {
            background-color: #8b5cf6;
            color: #f3f4f6;
        }
        .visualization-bar {
            transition: all 0.5s ease;
        }
        .tooltip {
            position: absolute;
            background: #1f2937;
            color: #f3f4f6;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #374151;
        }
    </style>
</head>
<body class="bg-[#101827] text-[#f3f4f6] min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-[#1f2937] border-b border-[#374151] py-4 px-6">
        <h1 class="text-2xl font-bold text-center">Null Values Handling Explorer</h1>
    </header>

    <!-- Main Content -->
    <main class="flex-grow p-6 grid grid-cols-1 lg:grid-cols-12 gap-6">
        <!-- Control Panel -->
        <div class="lg:col-span-4 bg-[#1f2937] rounded-lg p-6 border border-[#374151] h-fit">
            <h2 class="text-lg font-bold mb-4 text-[#8b5cf6]">Data Configuration</h2>
            
            <!-- Dataset Size -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Dataset Size:</label>
                <div class="flex space-x-2">
                    <input type="range" id="rowSlider" min="5" max="20" value="10" class="flex-grow">
                    <span id="rowCount" class="text-[#9ca3af] text-sm w-8">10</span>
                </div>
            </div>

            <!-- Null Percentage -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Null Percentage:</label>
                <div class="flex space-x-2">
                    <input type="range" id="nullSlider" min="0" max="50" value="20" class="flex-grow">
                    <span id="nullPercent" class="text-[#9ca3af] text-sm w-12">20%</span>
                </div>
            </div>

            <!-- Strategy Selection -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Handling Strategy:</label>
                <div class="space-y-2">
                    <button id="dropStrategy" class="strategy-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-trash mr-2"></i>Drop Null Values
                    </button>
                    <button id="meanStrategy" class="strategy-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-calculator mr-2"></i>Mean Imputation
                    </button>
                    <button id="medianStrategy" class="strategy-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-chart-line mr-2"></i>Median Imputation
                    </button>
                    <button id="modeStrategy" class="strategy-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-chart-bar mr-2"></i>Mode Imputation
                    </button>
                    <button id="forwardStrategy" class="strategy-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-arrow-right mr-2"></i>Forward Fill
                    </button>
                </div>
            </div>

            <!-- Control Buttons -->
            <div class="space-y-2">
                <button id="generateBtn" class="w-full bg-[#8b5cf6] hover:bg-[#a78bfa] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-dice mr-2"></i>Generate New Data
                </button>
                <button id="applyBtn" class="w-full bg-[#059669] hover:bg-[#10b981] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-play mr-2"></i>Apply Strategy
                </button>
                <button id="resetBtn" class="w-full bg-[#dc2626] hover:bg-[#ef4444] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-undo mr-2"></i>Reset
                </button>
            </div>

            <!-- Statistics -->
            <div id="statistics" class="mt-6 p-4 bg-[#101827] rounded border border-[#374151]">
                <h3 class="text-sm font-bold mb-2 text-[#8b5cf6]">Statistics</h3>
                <div class="text-xs space-y-1 text-[#9ca3af]">
                    <div>Original Rows: <span id="originalRows">10</span></div>
                    <div>Null Values: <span id="nullValues">2</span></div>
                    <div>After Handling: <span id="afterRows">10</span></div>
                    <div>Data Loss: <span id="dataLoss">0%</span></div>
                </div>
            </div>
        </div>

        <!-- Data Visualization -->
        <div class="lg:col-span-8 bg-[#1f2937] rounded-lg p-6 border border-[#374151]">
            <h2 class="text-lg font-bold mb-4 text-[#8b5cf6]">Data Visualization</h2>
            
            <!-- Dataset Table -->
            <div class="mb-6">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-sm font-medium">Dataset Table</h3>
                    <div class="flex space-x-4 text-xs">
                        <div class="flex items-center space-x-1">
                            <div class="w-3 h-3 bg-[#dc2626] rounded"></div>
                            <span class="text-[#9ca3af]">Null</span>
                        </div>
                        <div class="flex items-center space-x-1">
                            <div class="w-3 h-3 bg-[#d97706] rounded"></div>
                            <span class="text-[#9ca3af]">Imputed</span>
                        </div>
                        <div class="flex items-center space-x-1">
                            <div class="w-3 h-3 bg-[#059669] rounded"></div>
                            <span class="text-[#9ca3af]">Original</span>
                        </div>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full text-xs">
                        <thead>
                            <tr class="border-b border-[#374151]">
                                <th class="text-left p-2">ID</th>
                                <th class="text-left p-2">Value A</th>
                                <th class="text-left p-2">Value B</th>
                                <th class="text-left p-2">Category</th>
                            </tr>
                        </thead>
                        <tbody id="dataTable">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Impact Visualization -->
            <div>
                <h3 class="text-sm font-medium mb-2">Strategy Impact</h3>
                <div id="impactChart" class="space-y-2">
                    <!-- Impact bars will be inserted here -->
                </div>
            </div>

            <!-- Strategy Explanation -->
            <div id="strategyExplanation" class="mt-6 p-4 bg-[#101827] rounded border border-[#374151]">
                <h3 class="text-sm font-bold mb-2 text-[#8b5cf6]">How It Works</h3>
                <p class="text-xs text-[#9ca3af]">Select a strategy to see how it handles null values in your dataset. Each approach has different trade-offs in terms of data preservation and accuracy.</p>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-[#1f2937] border-t border-[#374151] py-4 px-6 mt-auto">
        <div class="flex justify-center space-x-6">
            <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-linkedin fa-2x"></i>
            </a>
            <a href="https://github.com/AshishJangra27" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-github fa-2x"></i>
            </a>
            <a href="https://www.kaggle.com/ashishjangra27" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-kaggle fa-2x"></i>
            </a>
            <a href="https://huggingface.co/ashish-jangra" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm0 2.4c5.302 0 9.6 4.298 9.6 9.6s-4.298 9.6-9.6 9.6S2.4 17.302 2.4 12 6.698 2.4 12 2.4z"/>
                    <path d="M8.4 9.6a1.2 1.2 0 1 1 2.4 0 1.2 1.2 0 0 1-2.4 0zm4.8 0a1.2 1.2 0 1 1 2.4 0 1.2 1.2 0 0 1-2.4 0z"/>
                    <path d="M7.2 14.4c0 2.64 2.16 4.8 4.8 4.8s4.8-2.16 4.8-4.8H7.2z"/>
                </svg>
            </a>
            <a href="https://www.instagram.com/ashish_zangra/" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-instagram fa-2x"></i>
            </a>
        </div>
    </footer>

    <script>
        // Application state
        let originalData = [];
        let currentData = [];
        let selectedStrategy = null;

        // DOM elements
        const rowSlider = document.getElementById('rowSlider');
        const rowCount = document.getElementById('rowCount');
        const nullSlider = document.getElementById('nullSlider');
        const nullPercent = document.getElementById('nullPercent');
        const dataTable = document.getElementById('dataTable');
        const impactChart = document.getElementById('impactChart');
        const statistics = document.getElementById('statistics');
        const strategyExplanation = document.getElementById('strategyExplanation');

        // Strategy buttons
        const strategyButtons = document.querySelectorAll('.strategy-button');
        const generateBtn = document.getElementById('generateBtn');
        const applyBtn = document.getElementById('applyBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Strategy explanations
        const strategyInfo = {
            drop: {
                title: "Drop Null Values",
                description: "Removes all rows containing null values. Simple but can lead to significant data loss. Best when nulls are random and dataset is large.",
                pros: ["Simple to implement", "No bias introduced"],
                cons: ["Data loss", "May remove important patterns"]
            },
            mean: {
                title: "Mean Imputation",
                description: "Replaces null values with the arithmetic mean of non-null values. Works well for numerical data with normal distribution.",
                pros: ["Preserves dataset size", "Simple calculation"],
                cons: ["Reduces variance", "May not work with skewed data"]
            },
            median: {
                title: "Median Imputation",
                description: "Replaces null values with the median. More robust to outliers than mean imputation. Good for skewed distributions.",
                pros: ["Robust to outliers", "Preserves dataset size"],
                cons: ["Less precise than mean for normal data", "Reduces variance"]
            },
            mode: {
                title: "Mode Imputation",
                description: "Replaces null values with the most frequent value. Best for categorical data or discrete numerical values.",
                pros: ["Works for categorical data", "Preserves common patterns"],
                cons: ["May increase bias toward common values", "Not suitable for continuous data"]
            },
            forward: {
                title: "Forward Fill",
                description: "Replaces null values with the last known value. Useful for time series data where values tend to persist.",
                pros: ["Maintains temporal continuity", "No statistical assumptions"],
                cons: ["May propagate outdated values", "Not suitable for all data types"]
            }
        };

        // Initialize application
        function init() {
            generateData();
            setupEventListeners();
            updateUI();
        }

        // Setup event listeners
        function setupEventListeners() {
            <!-- Generate new data automatically when sliders change -->
            rowSlider.addEventListener('input', function() {
                rowCount.textContent = this.value;
                generateData();
            });

            nullSlider.addEventListener('input', function() {
                nullPercent.textContent = this.value + '%';
                generateData();
            });

            strategyButtons.forEach(button => {
                button.addEventListener('click', function() {
                    strategyButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    const strategyMap = {
                        'dropStrategy': 'drop',
                        'meanStrategy': 'mean',
                        'medianStrategy': 'median',
                        'modeStrategy': 'mode',
                        'forwardStrategy': 'forward'
                    };
                    
                    selectedStrategy = strategyMap[this.id];
                    updateStrategyExplanation();
                });
            });

            generateBtn.addEventListener('click', generateData);
            applyBtn.addEventListener('click', applyStrategy);
            resetBtn.addEventListener('click', resetData);
        }

        // Generate random dataset
        function generateData() {
            const rows = parseInt(rowSlider.value);
            const nullPercentage = parseInt(nullSlider.value);
            
            originalData = [];
            
            const categories = ['A', 'B', 'C', 'D'];
            
            for (let i = 1; i <= rows; i++) {
                const row = {
                    id: i,
                    valueA: Math.round(Math.random() * 100),
                    valueB: Math.round(Math.random() * 50 + 25),
                    category: categories[Math.floor(Math.random() * categories.length)]
                };
                
                // Introduce null values
                if (Math.random() * 100 < nullPercentage) {
                    const fields = ['valueA', 'valueB', 'category'];
                    const fieldToNull = fields[Math.floor(Math.random() * fields.length)];
                    row[fieldToNull] = null;
                }
                
                originalData.push(row);
            }
            
            currentData = JSON.parse(JSON.stringify(originalData));
            updateUI();
        }

        // Apply selected strategy
        function applyStrategy() {
            if (!selectedStrategy) {
                alert('Please select a strategy first!');
                return;
            }

            currentData = JSON.parse(JSON.stringify(originalData));

            switch (selectedStrategy) {
                case 'drop':
                    applyDropStrategy();
                    break;
                case 'mean':
                    applyMeanImputation();
                    break;
                case 'median':
                    applyMedianImputation();
                    break;
                case 'mode':
                    applyModeImputation();
                    break;
                case 'forward':
                    applyForwardFill();
                    break;
            }

            updateUI();
            updateImpactVisualization();
        }

        // Strategy implementations
        function applyDropStrategy() {
            currentData = currentData.filter(row => 
                row.valueA !== null && row.valueB !== null && row.category !== null
            );
        }

        function applyMeanImputation() {
            const valueAMean = calculateMean(currentData, 'valueA');
            const valueBMean = calculateMean(currentData, 'valueB');

            currentData.forEach(row => {
                if (row.valueA === null) {
                    row.valueA = Math.round(valueAMean);
                    row._imputedA = true;
                }
                if (row.valueB === null) {
                    row.valueB = Math.round(valueBMean);
                    row._imputedB = true;
                }
                if (row.category === null) {
                    row.category = calculateMode(currentData, 'category');
                    row._imputedCategory = true;
                }
            });
        }

        function applyMedianImputation() {
            const valueAMedian = calculateMedian(currentData, 'valueA');
            const valueBMedian = calculateMedian(currentData, 'valueB');

            currentData.forEach(row => {
                if (row.valueA === null) {
                    row.valueA = valueAMedian;
                    row._imputedA = true;
                }
                if (row.valueB === null) {
                    row.valueB = valueBMedian;
                    row._imputedB = true;
                }
                if (row.category === null) {
                    row.category = calculateMode(currentData, 'category');
                    row._imputedCategory = true;
                }
            });
        }

        function applyModeImputation() {
            const valueAMode = calculateMode(currentData, 'valueA');
            const valueBMode = calculateMode(currentData, 'valueB');
            const categoryMode = calculateMode(currentData, 'category');

            currentData.forEach(row => {
                if (row.valueA === null) {
                    row.valueA = valueAMode;
                    row._imputedA = true;
                }
                if (row.valueB === null) {
                    row.valueB = valueBMode;
                    row._imputedB = true;
                }
                if (row.category === null) {
                    row.category = categoryMode;
                    row._imputedCategory = true;
                }
            });
        }

        function applyForwardFill() {
            let lastValueA = null;
            let lastValueB = null;
            let lastCategory = null;

            currentData.forEach(row => {
                if (row.valueA !== null) lastValueA = row.valueA;
                if (row.valueB !== null) lastValueB = row.valueB;
                if (row.category !== null) lastCategory = row.category;

                if (row.valueA === null && lastValueA !== null) {
                    row.valueA = lastValueA;
                    row._imputedA = true;
                }
                if (row.valueB === null && lastValueB !== null) {
                    row.valueB = lastValueB;
                    row._imputedB = true;
                }
                if (row.category === null && lastCategory !== null) {
                    row.category = lastCategory;
                    row._imputedCategory = true;
                }
            });
            
            // Handle remaining nulls at the beginning if first rows have nulls
            const remainingNulls = currentData.filter(row => 
                row.valueA === null || row.valueB === null || row.category === null
            );
            
            if (remainingNulls.length > 0) {
                // Use mode imputation for remaining nulls
                const valueAMode = calculateMode(currentData, 'valueA');
                const valueBMode = calculateMode(currentData, 'valueB');
                const categoryMode = calculateMode(currentData, 'category');
                
                remainingNulls.forEach(row => {
                    if (row.valueA === null) {
                        row.valueA = valueAMode || 0;
                        row._imputedA = true;
                    }
                    if (row.valueB === null) {
                        row.valueB = valueBMode || 0;
                        row._imputedB = true;
                    }
                    if (row.category === null) {
                        row.category = categoryMode || 'A';
                        row._imputedCategory = true;
                    }
                });
            }
        }

        // Utility functions
        function calculateMean(data, field) {
            const values = data.filter(row => row[field] !== null).map(row => row[field]);
            return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : 0;
        }

        function calculateMedian(data, field) {
            const values = data.filter(row => row[field] !== null).map(row => row[field]).sort((a, b) => a - b);
            if (values.length === 0) return 0;
            const mid = Math.floor(values.length / 2);
            return values.length % 2 === 0 ? Math.round((values[mid - 1] + values[mid]) / 2) : values[mid];
        }

        function calculateMode(data, field) {
            const values = data.filter(row => row[field] !== null).map(row => row[field]);
            if (values.length === 0) return null;
            
            const frequency = {};
            values.forEach(value => frequency[value] = (frequency[value] || 0) + 1);
            
            let maxCount = 0;
            let mode = null;
            
            for (const value in frequency) {
                if (frequency[value] > maxCount) {
                    maxCount = frequency[value];
                    mode = isNaN(value) ? value : Number(value);
                }
            }
            
            return mode;
        }

        // Reset data
        function resetData() {
            currentData = JSON.parse(JSON.stringify(originalData));
            selectedStrategy = null;
            strategyButtons.forEach(btn => btn.classList.remove('active'));
            
            // Clear impact chart
            impactChart.innerHTML = '';
            
            updateUI();
            updateStrategyExplanation();
        }

        // Update UI
        function updateUI() {
            updateDataTable();
            updateStatistics();
        }

        // Update data table
        function updateDataTable() {
            dataTable.innerHTML = '';
            
            if (currentData.length === 0) {
                const tr = document.createElement('tr');
                tr.innerHTML = '<td colspan="4" class="p-4 text-center text-[#9ca3af]">No data available</td>';
                dataTable.appendChild(tr);
                return;
            }
            
            currentData.forEach(row => {
                const tr = document.createElement('tr');
                tr.classList.add('border-b', 'border-[#374151]');
                
                const getCellClass = (value, field) => {
                    if (value === null) return 'data-cell null';
                    if (row[`_imputed${field.charAt(0).toUpperCase() + field.slice(1)}`]) return 'data-cell imputed';
                    return 'data-cell filled';
                };
                
                const getCellTitle = (value, field) => {
                    if (value === null) return 'Null value';
                    if (row[`_imputed${field.charAt(0).toUpperCase() + field.slice(1)}`]) return 'Imputed value';
                    return 'Original value';
                };
                
                tr.innerHTML = `
                    <td class="p-2">${row.id}</td>
                    <td class="p-2 ${getCellClass(row.valueA, 'valueA')}" title="${getCellTitle(row.valueA, 'valueA')}">${row.valueA === null ? 'NULL' : row.valueA}</td>
                    <td class="p-2 ${getCellClass(row.valueB, 'valueB')}" title="${getCellTitle(row.valueB, 'valueB')}">${row.valueB === null ? 'NULL' : row.valueB}</td>
                    <td class="p-2 ${getCellClass(row.category, 'category')}" title="${getCellTitle(row.category, 'category')}">${row.category === null ? 'NULL' : row.category}</td>
                `;
                
                dataTable.appendChild(tr);
            });
        }

        // Update statistics
        function updateStatistics() {
            const originalRows = originalData.length;
            const currentRows = currentData.length;
            const nullCount = originalData.reduce((count, row) => {
                let nullsInRow = 0;
                if (row.valueA === null) nullsInRow++;
                if (row.valueB === null) nullsInRow++;
                if (row.category === null) nullsInRow++;
                return count + nullsInRow;
            }, 0);
            const dataLoss = originalRows > 0 ? Math.round(((originalRows - currentRows) / originalRows) * 100) : 0;

            document.getElementById('originalRows').textContent = originalRows;
            document.getElementById('nullValues').textContent = nullCount;
            document.getElementById('afterRows').textContent = currentRows;
            document.getElementById('dataLoss').textContent = dataLoss + '%';
        }

        // Update impact visualization
        function updateImpactVisualization() {
            if (!selectedStrategy) return;

            impactChart.innerHTML = '';
            
            const metrics = [
                { label: 'Data Preservation', value: (currentData.length / originalData.length) * 100 },
                { label: 'Value Accuracy', value: calculateAccuracy() },
                { label: 'Distribution Impact', value: calculateDistributionImpact() }
            ];

            metrics.forEach(metric => {
                const bar = document.createElement('div');
                bar.className = 'flex items-center space-x-2';
                bar.innerHTML = `
                    <span class="text-xs w-24">${metric.label}:</span>
                    <div class="flex-grow bg-[#374151] rounded-full h-3">
                        <div class="visualization-bar bg-[#8b5cf6] h-3 rounded-full transition-all duration-500" style="width: ${metric.value}%"></div>
                    </div>
                    <span class="text-xs text-[#9ca3af] w-10">${Math.round(metric.value)}%</span>
                `;
                impactChart.appendChild(bar);
            });
        }

        // Calculate accuracy metric
        function calculateAccuracy() {
            if (selectedStrategy === 'drop') return 100;
            
            let totalOriginalCells = originalData.length * 3; // valueA, valueB, category
            let totalImputedCells = 0;
            
            currentData.forEach(row => {
                if (row._imputedA) totalImputedCells++;
                if (row._imputedB) totalImputedCells++;
                if (row._imputedCategory) totalImputedCells++;
            });
            
            if (totalOriginalCells === 0) return 100;
            
            // Higher accuracy means fewer cells were imputed
            return Math.max(0, Math.round(100 - (totalImputedCells / totalOriginalCells) * 100));
        }

        // Calculate distribution impact
        function calculateDistributionImpact() {
            // Simplified metric - in practice, this would involve statistical tests
            const nullCount = originalData.reduce((count, row) => {
                return count + Object.values(row).filter(v => v === null).length - (row.id === null ? 1 : 0);
            }, 0);
            
            return Math.max(0, 100 - (nullCount / (originalData.length * 3)) * 100);
        }

        // Update strategy explanation
        function updateStrategyExplanation() {
            if (!selectedStrategy) {
                strategyExplanation.innerHTML = `
                    <h3 class="text-sm font-bold mb-2 text-[#8b5cf6]">How It Works</h3>
                    <p class="text-xs text-[#9ca3af]">Select a strategy to see how it handles null values in your dataset. Each approach has different trade-offs in terms of data preservation and accuracy.</p>
                `;
                return;
            }

            const info = strategyInfo[selectedStrategy];
            strategyExplanation.innerHTML = `
                <h3 class="text-sm font-bold mb-2 text-[#8b5cf6]">${info.title}</h3>
                <p class="text-xs text-[#9ca3af] mb-3">${info.description}</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-xs font-medium text-[#059669] mb-1">Pros:</h4>
                        <ul class="text-xs text-[#9ca3af] space-y-1">
                            ${info.pros.map(pro => `<li>• ${pro}</li>`).join('')}
                        </ul>
                    </div>
                    <div>
                        <h4 class="text-xs font-medium text-[#dc2626] mb-1">Cons:</h4>
                        <ul class="text-xs text-[#9ca3af] space-y-1">
                            ${info.cons.map(con => `<li>• ${con}</li>`).join('')}
                        </ul>
                    </div>
                </div>
            `;
        }

        // Initialize the application
        init();
    </script>
</body>
</html>
