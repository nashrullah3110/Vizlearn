<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZT6JM33V5J"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-ZT6JM33V5J');
        </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex Operations Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
        }
        .regex-match {
            background-color: #8b5cf6;
            color: #f3f4f6;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .regex-group {
            background-color: #059669;
            color: #f0fdf4;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        .regex-group-1 { background-color: #ef4444; }
        .regex-group-2 { background-color: #f97316; }
        .regex-group-3 { background-color: #eab308; }
        .regex-group-4 { background-color: #22c55e; }
        .regex-group-5 { background-color: #3b82f6; }
        .code-editor {
            background-color: #0f172a;
            border: 1px solid #374151;
            border-radius: 6px;
            color: #e2e8f0;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 12px;
            resize: vertical;
            min-height: 80px;
        }
        .level-button.active {
            background-color: #8b5cf6;
            color: #f3f4f6;
        }
        .pattern-button.active {
            background-color: #059669;
            color: #f3f4f6;
        }
        .visualization-bar {
            transition: all 0.5s ease;
        }
        .regex-explanation {
            background-color: #1e293b;
            border-left: 4px solid #8b5cf6;
            padding: 12px;
            margin: 8px 0;
        }
        .match-animation {
            animation: matchHighlight 0.8s ease-in-out;
        }
        @keyframes matchHighlight {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(139, 92, 246, 0.3); }
        }
    </style>
</head>
<body class="bg-[#101827] text-[#f3f4f6] min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-[#1f2937] border-b border-[#374151] py-4 px-6">
        <h1 class="text-2xl font-bold text-center">Regex Operations Explorer</h1>
        <p class="text-center text-sm text-[#9ca3af] mt-1">From Basic to Advanced Python Regular Expressions</p>
    </header>

    <!-- Main Content -->
    <main class="flex-grow p-6 grid grid-cols-1 lg:grid-cols-12 gap-6">
        <!-- Control Panel -->
        <div class="lg:col-span-4 bg-[#1f2937] rounded-lg p-6 border border-[#374151] h-fit">
            <h2 class="text-lg font-bold mb-4 text-[#8b5cf6]">Regex Learning Hub</h2>
            
            <!-- Difficulty Level -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Learning Level:</label>
                <div class="space-y-2">
                    <button id="basicLevel" class="level-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-star mr-2"></i>Basic Patterns
                    </button>
                    <button id="intermediateLevel" class="level-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-star mr-2"></i><i class="fas fa-star mr-2"></i>Intermediate Concepts
                    </button>
                    <button id="advancedLevel" class="level-button w-full text-left px-3 py-2 rounded border border-[#374151] hover:bg-[#8b5cf6] hover:text-[#f3f4f6] transition-colors">
                        <i class="fas fa-star mr-2"></i><i class="fas fa-star mr-2"></i><i class="fas fa-star mr-2"></i>Advanced Techniques
                    </button>
                </div>
            </div>

            <!-- Pattern Templates -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Pattern Templates:</label>
                <div id="patternButtons" class="space-y-1 max-h-48 overflow-y-auto">
                    <!-- Pattern buttons will be inserted here -->
                </div>
            </div>

            <!-- Regex Input -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Regular Expression:</label>
                <input type="text" id="regexInput" placeholder="Enter your regex pattern..." 
                       class="w-full px-3 py-2 bg-[#0f172a] border border-[#374151] rounded text-[#e2e8f0] placeholder-[#9ca3af] focus:border-[#8b5cf6] focus:outline-none">
                <div class="flex items-center mt-2 space-x-4">
                    <label class="flex items-center text-xs">
                        <input type="checkbox" id="globalFlag" class="mr-1 accent-[#8b5cf6]">
                        Global (g)
                    </label>
                    <label class="flex items-center text-xs">
                        <input type="checkbox" id="caseFlag" class="mr-1 accent-[#8b5cf6]">
                        Ignore Case (i)
                    </label>
                    <label class="flex items-center text-xs">
                        <input type="checkbox" id="multilineFlag" class="mr-1 accent-[#8b5cf6]">
                        Multiline (m)
                    </label>
                </div>
            </div>

            <!-- Test String -->
            <div class="mb-6">
                <label class="block text-sm font-medium mb-2">Test String:</label>
                <textarea id="testString" rows="4" placeholder="Enter text to test against..." 
                          class="code-editor w-full"></textarea>
            </div>

            <!-- Control Buttons -->
            <div class="space-y-2">
                <button id="testBtn" class="w-full bg-[#8b5cf6] hover:bg-[#a78bfa] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-play mr-2"></i>Test Regex
                </button>
                <button id="explainBtn" class="w-full bg-[#059669] hover:bg-[#10b981] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-lightbulb mr-2"></i>Explain Pattern
                </button>
                <button id="generateBtn" class="w-full bg-[#f59e0b] hover:bg-[#fbbf24] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-dice mr-2"></i>Generate Sample Text
                </button>
                <button id="clearBtn" class="w-full bg-[#dc2626] hover:bg-[#ef4444] text-white py-2 px-4 rounded transition-colors">
                    <i class="fas fa-eraser mr-2"></i>Clear All
                </button>
            </div>

            <!-- Quick Stats -->
            <div id="quickStats" class="mt-6 p-4 bg-[#101827] rounded border border-[#374151]">
                <h3 class="text-sm font-bold mb-2 text-[#8b5cf6]">Match Statistics</h3>
                <div class="text-xs space-y-1 text-[#9ca3af]">
                    <div>Total Matches: <span id="totalMatches">0</span></div>
                    <div>Capture Groups: <span id="captureGroups">0</span></div>
                    <div>Pattern Length: <span id="patternLength">0</span></div>
                    <div>Success Rate: <span id="successRate">0%</span></div>
                </div>
            </div>
        </div>

        <!-- Main Workspace -->
        <div class="lg:col-span-8 bg-[#1f2937] rounded-lg p-6 border border-[#374151]">
            <h2 class="text-lg font-bold mb-4 text-[#8b5cf6]">Regex Workspace</h2>
            
            <!-- Results Visualization -->
            <div class="mb-6">
                <h3 class="text-sm font-medium mb-2">Match Results</h3>
                <div id="matchResults" class="p-4 bg-[#0f172a] rounded border border-[#374151] min-h-32 max-h-64 overflow-y-auto">
                    <p class="text-[#9ca3af] text-sm">Enter a regex pattern and test string to see matches...</p>
                </div>
            </div>

            <!-- Groups Breakdown -->
            <div class="mb-6">
                <h3 class="text-sm font-medium mb-2">Capture Groups</h3>
                <div id="groupsBreakdown" class="space-y-2 max-h-32 overflow-y-auto">
                    <p class="text-[#9ca3af] text-sm">No capture groups found</p>
                </div>
            </div>

            <!-- Python Code Generation -->
            <div class="mb-6">
                <h3 class="text-sm font-medium mb-2">Python Implementation</h3>
                <div id="pythonCode" class="code-editor min-h-24 max-h-48 overflow-y-auto">
                    <span class="text-[#9ca3af]"># Python code will be generated here...</span>
                </div>
                <button id="copyCodeBtn" class="mt-2 px-3 py-1 bg-[#374151] hover:bg-[#4b5563] text-xs rounded transition-colors">
                    <i class="fas fa-copy mr-1"></i>Copy Code
                </button>
            </div>

            <!-- Pattern Explanation -->
            <div id="patternExplanation" class="mb-6">
                <h3 class="text-sm font-medium mb-2">Pattern Breakdown</h3>
                <div class="p-4 bg-[#101827] rounded border border-[#374151] min-h-24">
                    <p class="text-[#9ca3af] text-sm">Select a pattern or enter your own to see detailed explanation...</p>
                </div>
            </div>

            <!-- Learning Resources -->
            <div id="learningTips" class="p-4 bg-[#101827] rounded border border-[#374151]">
                <h3 class="text-sm font-bold mb-2 text-[#8b5cf6]">Learning Tips</h3>
                <div class="text-xs text-[#9ca3af] space-y-1">
                    <div>• Start with basic patterns and gradually increase complexity</div>
                    <div>• Use the global flag to find all matches, not just the first one</div>
                    <div>• Capture groups help extract specific parts of matches</div>
                    <div>• Test your patterns with various input scenarios</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-[#1f2937] border-t border-[#374151] py-4 px-6 mt-auto">
        <div class="flex justify-center space-x-6">
            <a href="https://www.linkedin.com/in/ashish-jangra/" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-linkedin fa-2x"></i>
            </a>
            <a href="https://github.com/AshishJangra27" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-github fa-2x"></i>
            </a>
            <a href="https://www.kaggle.com/ashishjangra27" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-kaggle fa-2x"></i>
            </a>
            <a href="https://huggingface.co/ashish-jangra" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm0 2.4c5.302 0 9.6 4.298 9.6 9.6s-4.298 9.6-9.6 9.6S2.4 17.302 2.4 12 6.698 2.4 12 2.4z"/>
                    <path d="M8.4 9.6a1.2 1.2 0 1 1 2.4 0 1.2 1.2 0 0 1-2.4 0zm4.8 0a1.2 1.2 0 1 1 2.4 0 1.2 1.2 0 0 1-2.4 0z"/>
                    <path d="M7.2 14.4c0 2.64 2.16 4.8 4.8 4.8s4.8-2.16 4.8-4.8H7.2z"/>
                </svg>
            </a>
            <a href="https://www.instagram.com/ashish_zangra/" target="_blank" class="text-[#9ca3af] hover:text-[#a78bfa] transition-colors">
                <i class="fab fa-instagram fa-2x"></i>
            </a>
        </div>
    </footer>

    <script>
        // Application state
        let currentLevel = 'basic';
        let selectedPattern = null;
        let lastMatchResults = [];

        // Regex patterns organized by difficulty
        const regexPatterns = {
            basic: [
                { name: 'Literal Text', pattern: 'hello', desc: 'Matches exact text "hello"' },
                { name: 'Any Character', pattern: '.', desc: 'Matches any single character' },
                { name: 'Digit', pattern: '\\d', desc: 'Matches any digit (0-9)' },
                { name: 'Word Character', pattern: '\\w', desc: 'Matches any word character (a-z, A-Z, 0-9, _)' },
                { name: 'Whitespace', pattern: '\\s', desc: 'Matches any whitespace character' },
                { name: 'Start of String', pattern: '^hello', desc: 'Matches "hello" at the start of string' },
                { name: 'End of String', pattern: 'world$', desc: 'Matches "world" at the end of string' },
                { name: 'Character Class', pattern: '[aeiou]', desc: 'Matches any vowel' },
                { name: 'Negated Class', pattern: '[^0-9]', desc: 'Matches any non-digit' },
                { name: 'Range', pattern: '[a-z]', desc: 'Matches any lowercase letter' }
            ],
            intermediate: [
                { name: 'One or More', pattern: '\\d+', desc: 'Matches one or more digits' },
                { name: 'Zero or More', pattern: '\\w*', desc: 'Matches zero or more word characters' },
                { name: 'Zero or One', pattern: 'colou?r', desc: 'Matches "color" or "colour"' },
                { name: 'Exact Count', pattern: '\\d{3}', desc: 'Matches exactly 3 digits' },
                { name: 'Range Count', pattern: '\\w{2,5}', desc: 'Matches 2 to 5 word characters' },
                { name: 'Alternation', pattern: 'cat|dog', desc: 'Matches either "cat" or "dog"' },
                { name: 'Simple Group', pattern: '(\\d+)', desc: 'Captures one or more digits' },
                { name: 'Email Basic', pattern: '\\w+@\\w+\\.\\w+', desc: 'Basic email pattern' },
                { name: 'Phone Number', pattern: '\\d{3}-\\d{3}-\\d{4}', desc: 'US phone number format' },
                { name: 'Word Boundary', pattern: '\\bword\\b', desc: 'Matches "word" as complete word' }
            ],
            advanced: [
                { name: 'Lookahead', pattern: '\\d+(?=px)', desc: 'Digits followed by "px"' },
                { name: 'Negative Lookahead', pattern: '\\d+(?!px)', desc: 'Digits not followed by "px"' },
                { name: 'Lookbehind', pattern: '(?<=\\$)\\d+', desc: 'Digits preceded by "$"' },
                { name: 'Named Groups', pattern: '(?P<year>\\d{4})-(?P<month>\\d{2})', desc: 'Named capture groups' },
                { name: 'Non-Capturing', pattern: '(?:cat|dog)s?', desc: 'Non-capturing group for alternation' },
                { name: 'Backreference', pattern: '(\\w+)\\s+\\1', desc: 'Matches repeated words' },
                { name: 'Conditional', pattern: '(\\d+)?(?(1)\\d{2}|\\w{2})', desc: 'Conditional pattern' },
                { name: 'Complex Email', pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', desc: 'Complete email validation' },
                { name: 'URL Pattern', pattern: 'https?://[\\w.-]+\\.[a-zA-Z]{2,}(/[\\w.-]*)*/?', desc: 'URL matching' },
                { name: 'JSON Key-Value', pattern: '"([^"]+)"\\s*:\\s*"([^"]+)"', desc: 'JSON key-value pairs' }
            ]
        };

        // Sample texts for different patterns
        const sampleTexts = {
            basic: `Hello world! This is a test string with numbers 123 and symbols @#$%.
Multiple lines are here.
Testing various characters: abc ABC 123 !@#`,
            
            intermediate: `Contact emails: john@example.com, mary.smith@company.org
Phone numbers: 123-456-7890, 555-123-4567
Words with colors: red, blue, green, colour, color
Repeated text: the the, and and, but but`,
            
            advanced: `Prices: $25, $100px, 50px, 75em, 200pt
Dates: 2024-01-15, 2023-12-31, 2022-06-30
URLs: https://example.com, http://test.org/path/to/page
JSON: {"name": "John", "age": "30", "city": "New York"}
Duplicates: hello hello, world world, test test`
        };

        // DOM elements
        const regexInput = document.getElementById('regexInput');
        const testString = document.getElementById('testString');
        const matchResults = document.getElementById('matchResults');
        const groupsBreakdown = document.getElementById('groupsBreakdown');
        const pythonCode = document.getElementById('pythonCode');
        const patternExplanation = document.getElementById('patternExplanation');
        const patternButtons = document.getElementById('patternButtons');
        
        // Checkboxes
        const globalFlag = document.getElementById('globalFlag');
        const caseFlag = document.getElementById('caseFlag');
        const multilineFlag = document.getElementById('multilineFlag');
        
        // Buttons
        const levelButtons = document.querySelectorAll('.level-button');
        const testBtn = document.getElementById('testBtn');
        const explainBtn = document.getElementById('explainBtn');
        const generateBtn = document.getElementById('generateBtn');
        const clearBtn = document.getElementById('clearBtn');
        const copyCodeBtn = document.getElementById('copyCodeBtn');

        // Initialize application
        function init() {
            setupEventListeners();
            loadLevel('basic');
            globalFlag.checked = true; // Default to global matching
        }

        // Setup event listeners
        function setupEventListeners() {
            // Level selection
            levelButtons.forEach(button => {
                button.addEventListener('click', function() {
                    levelButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    const levelMap = {
                        'basicLevel': 'basic',
                        'intermediateLevel': 'intermediate',
                        'advancedLevel': 'advanced'
                    };
                    
                    currentLevel = levelMap[this.id];
                    loadLevel(currentLevel);
                });
            });

            // Input changes
            regexInput.addEventListener('input', debounce(testRegex, 300));
            testString.addEventListener('input', debounce(testRegex, 300));
            
            // Flag changes
            [globalFlag, caseFlag, multilineFlag].forEach(checkbox => {
                checkbox.addEventListener('change', testRegex);
            });

            // Button actions
            testBtn.addEventListener('click', testRegex);
            explainBtn.addEventListener('click', explainPattern);
            generateBtn.addEventListener('click', generateSampleText);
            clearBtn.addEventListener('click', clearAll);
            copyCodeBtn.addEventListener('click', copyPythonCode);
        }

        // Load patterns for selected level
        function loadLevel(level) {
            const patterns = regexPatterns[level];
            patternButtons.innerHTML = '';
            
            patterns.forEach((pattern, index) => {
                const button = document.createElement('button');
                button.className = 'pattern-button w-full text-left px-2 py-1 rounded border border-[#374151] hover:bg-[#059669] hover:text-[#f3f4f6] transition-colors text-xs';
                button.innerHTML = `<code class="text-[#8b5cf6]">${escapeHtml(pattern.pattern)}</code> - ${pattern.name}`;
                button.addEventListener('click', () => selectPattern(pattern, button));
                patternButtons.appendChild(button);
            });
            
            // Load sample text for the level
            testString.value = sampleTexts[level];
            
            // Clear current selections
            document.querySelectorAll('.pattern-button').forEach(btn => btn.classList.remove('active'));
            selectedPattern = null;
            regexInput.value = '';
            clearResults();
        }

        // Select a pattern template
        function selectPattern(pattern, buttonElement) {
            // Update UI
            document.querySelectorAll('.pattern-button').forEach(btn => btn.classList.remove('active'));
            buttonElement.classList.add('active');
            
            // Update inputs
            selectedPattern = pattern;
            regexInput.value = pattern.pattern;
            
            // Test immediately
            testRegex();
            explainPattern();
        }

        // Test the regex pattern
        function testRegex() {
            const pattern = regexInput.value.trim();
            const text = testString.value;
            
            if (!pattern) {
                clearResults();
                return;
            }

            try {
                // Build flags
                let flags = '';
                if (globalFlag.checked) flags += 'g';
                if (caseFlag.checked) flags += 'i';
                if (multilineFlag.checked) flags += 'm';

                const regex = new RegExp(pattern, flags);
                
                // Use different approach for global vs non-global
                let matches = [];
                if (globalFlag.checked) {
                    matches = [...text.matchAll(regex)];
                } else {
                    const match = text.match(regex);
                    if (match) {
                        matches = [match];
                    }
                }
                
                lastMatchResults = matches;
                displayMatches(matches, text, regex);
                displayGroups(matches);
                generatePythonCode(pattern, flags);
                updateStats(matches, pattern);
                
            } catch (error) {
                displayError(error.message);
            }
        }

        // Display matches in the results area
        function displayMatches(matches, originalText, regex) {
            if (matches.length === 0) {
                matchResults.innerHTML = '<p class="text-[#dc2626] text-sm">No matches found</p>';
                return;
            }

            let displayText = escapeHtml(originalText);
            
            // Sort matches by index in reverse order to avoid offset issues
            const sortedMatches = [...matches].sort((a, b) => b.index - a.index);
            
            sortedMatches.forEach((match, index) => {
                const matchStart = match.index;
                const matchEnd = matchStart + match[0].length;
                
                const before = displayText.substring(0, matchStart);
                const matchText = escapeHtml(match[0]);
                const after = displayText.substring(matchEnd);
                
                displayText = before + `<span class="regex-match match-animation">${matchText}</span>` + after;
            });

            matchResults.innerHTML = `
                <div class="text-sm">
                    <div class="mb-2 text-[#059669]">${matches.length} match${matches.length > 1 ? 'es' : ''} found:</div>
                    <div class="whitespace-pre-wrap leading-relaxed">${displayText}</div>
                </div>
            `;
        }

        // Display capture groups
        function displayGroups(matches) {
            groupsBreakdown.innerHTML = '';
            
            if (matches.length === 0) {
                groupsBreakdown.innerHTML = '<p class="text-[#9ca3af] text-sm">No matches found</p>';
                return;
            }
            
            // Check if any matches have capture groups
            const hasGroups = matches.some(match => 
                (match.length > 1 && match.slice(1).some(g => g !== undefined)) ||
                (match.groups && Object.keys(match.groups).length > 0)
            );
            
            if (!hasGroups) {
                groupsBreakdown.innerHTML = '<p class="text-[#9ca3af] text-sm">No capture groups found</p>';
                return;
            }

            matches.forEach((match, matchIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'p-2 bg-[#101827] rounded border border-[#374151] mb-2';
                
                let groupsHtml = `<div class="text-xs font-medium mb-1 text-[#8b5cf6]">Match ${matchIndex + 1}: "${escapeHtml(match[0])}"</div>`;
                
                // Named groups (higher priority)
                if (match.groups && Object.keys(match.groups).length > 0) {
                    Object.entries(match.groups).forEach(([name, value]) => {
                        if (value !== undefined) {
                            groupsHtml += `<div class="text-xs"><span class="text-[#8b5cf6]">${name}:</span> <span class="regex-group">${escapeHtml(value)}</span></div>`;
                        }
                    });
                }
                
                // Numbered groups
                for (let i = 1; i < match.length; i++) {
                    if (match[i] !== undefined) {
                        const colorClass = `regex-group-${((i - 1) % 5) + 1}`;
                        groupsHtml += `<div class="text-xs"><span class="text-[#f59e0b]">Group ${i}:</span> <span class="${colorClass} regex-group">${escapeHtml(match[i])}</span></div>`;
                    }
                }
                
                groupDiv.innerHTML = groupsHtml;
                groupsBreakdown.appendChild(groupDiv);
            });
        }

        // Generate Python code
        function generatePythonCode(pattern, flags) {
            const flagMap = {
                'i': 're.IGNORECASE',
                'm': 're.MULTILINE',
                's': 're.DOTALL'
            };

            let pythonFlags = [];
            for (let flag of flags) {
                if (flagMap[flag]) {
                    pythonFlags.push(flagMap[flag]);
                }
            }

            const flagsStr = pythonFlags.length > 0 ? `, ${pythonFlags.join(' | ')}` : '';
            const isGlobal = flags.includes('g');
            
            // Escape the pattern for Python raw string
            const escapedPattern = pattern.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            const escapedText = testString.value.replace(/\\/g, '\\\\').replace(/'''/g, "\\'\\'\\'");

            const code = `import re

# Define pattern and text
pattern = r'${escapedPattern}'
text = '''${escapedText}'''

# Compile regex for better performance
regex = re.compile(pattern${flagsStr})

# Find matches
${isGlobal ? `matches = regex.findall(text)  # Find all matches
match_objects = list(regex.finditer(text))  # Get match objects with positions

print(f"Found {len(matches)} matches")
for i, match_obj in enumerate(match_objects):
    print(f"Match {i+1}: '{match_obj.group()}' at position {match_obj.start()}-{match_obj.end()}")
    
    # Access capture groups
    for j in range(1, len(match_obj.groups()) + 1):
        if match_obj.group(j) is not None:
            print(f"  Group {j}: '{match_obj.group(j)}'")
    
    # Access named groups (if any)
    if match_obj.groupdict():
        for name, value in match_obj.groupdict().items():
            if value is not None:
                print(f"  Named group '{name}': '{value}'")` : `match = regex.search(text)  # Find first match

if match:
    print(f"Match found: '{match.group()}' at position {match.start()}-{match.end()}")
    
    # Access capture groups
    for i in range(1, len(match.groups()) + 1):
        if match.group(i) is not None:
            print(f"  Group {i}: '{match.group(i)}'")
    
    # Access named groups (if any)
    if match.groupdict():
        for name, value in match.groupdict().items():
            if value is not None:
                print(f"  Named group '{name}': '{value}'")
else:
    print("No match found")`}

# Common regex operations
all_matches = regex.findall(text)
substituted = regex.sub('replacement', text)  # Replace matches
split_text = regex.split(text)  # Split by pattern`;

            pythonCode.textContent = code;
        }

        // Explain the current pattern
        function explainPattern() {
            const pattern = regexInput.value.trim();
            
            if (!pattern) {
                patternExplanation.querySelector('div').innerHTML = '<p class="text-[#9ca3af] text-sm">Enter a pattern to see explanation...</p>';
                return;
            }

            const explanation = explainRegexPattern(pattern);
            const explanationDiv = patternExplanation.querySelector('div');
            
            explanationDiv.innerHTML = `
                <div class="space-y-2">
                    <div class="text-sm font-medium text-[#8b5cf6]">Pattern: <code class="bg-[#0f172a] px-2 py-1 rounded">${escapeHtml(pattern)}</code></div>
                    ${explanation}
                    ${selectedPattern ? `<div class="text-xs text-[#9ca3af] mt-2">Template: ${selectedPattern.desc}</div>` : ''}
                </div>
            `;
        }

        // Generate sample text
        function generateSampleText() {
            testString.value = sampleTexts[currentLevel];
            if (regexInput.value) {
                testRegex();
            }
        }

        // Clear all inputs and results
        function clearAll() {
            regexInput.value = '';
            testString.value = '';
            globalFlag.checked = true;
            caseFlag.checked = false;
            multilineFlag.checked = false;
            clearResults();
            document.querySelectorAll('.pattern-button').forEach(btn => btn.classList.remove('active'));
            selectedPattern = null;
            lastMatchResults = [];
        }

        // Clear results displays
        function clearResults() {
            matchResults.innerHTML = '<p class="text-[#9ca3af] text-sm">Enter a regex pattern and test string to see matches...</p>';
            groupsBreakdown.innerHTML = '<p class="text-[#9ca3af] text-sm">No capture groups found</p>';
            pythonCode.textContent = '# Python code will be generated here...';
            patternExplanation.querySelector('div').innerHTML = '<p class="text-[#9ca3af] text-sm">Select a pattern or enter your own to see detailed explanation...</p>';
            updateStats([], '');
        }

        // Copy Python code to clipboard
        function copyPythonCode() {
            const codeText = pythonCode.textContent;
            if (!codeText || codeText.includes('# Python code will be generated here...')) {
                copyCodeBtn.innerHTML = '<i class="fas fa-exclamation mr-1"></i>No code to copy';
                setTimeout(() => {
                    copyCodeBtn.innerHTML = '<i class="fas fa-copy mr-1"></i>Copy Code';
                }, 2000);
                return;
            }
            
            navigator.clipboard.writeText(codeText).then(() => {
                const originalText = copyCodeBtn.innerHTML;
                copyCodeBtn.innerHTML = '<i class="fas fa-check mr-1"></i>Copied!';
                copyCodeBtn.classList.add('bg-[#059669]');
                setTimeout(() => {
                    copyCodeBtn.innerHTML = originalText;
                    copyCodeBtn.classList.remove('bg-[#059669]');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                copyCodeBtn.innerHTML = '<i class="fas fa-times mr-1"></i>Copy failed';
                setTimeout(() => {
                    copyCodeBtn.innerHTML = '<i class="fas fa-copy mr-1"></i>Copy Code';
                }, 2000);
            });
        }

        // Update statistics
        function updateStats(matches, pattern) {
            const totalMatches = matches.length;
            let uniqueGroups = 0;
            
            if (matches.length > 0) {
                // Count unique capture groups across all matches
                const groupCounts = new Set();
                matches.forEach(match => {
                    for (let i = 1; i < match.length; i++) {
                        if (match[i] !== undefined) {
                            groupCounts.add(i);
                        }
                    }
                    // Add named groups
                    if (match.groups) {
                        Object.keys(match.groups).forEach(name => groupCounts.add(name));
                    }
                });
                uniqueGroups = groupCounts.size;
            }
            
            const patternLength = pattern.length;
            const textWords = testString.value.trim().split(/\s+/).filter(word => word.length > 0);
            const successRate = textWords.length > 0 ? Math.round((totalMatches / textWords.length) * 100) : 0;

            document.getElementById('totalMatches').textContent = totalMatches;
            document.getElementById('captureGroups').textContent = uniqueGroups;
            document.getElementById('patternLength').textContent = patternLength;
            document.getElementById('successRate').textContent = Math.min(successRate, 100) + '%';
        }

        // Display error message
        function displayError(message) {
            matchResults.innerHTML = `<p class="text-[#dc2626] text-sm"><i class="fas fa-exclamation-triangle mr-1"></i>Regex Error: ${escapeHtml(message)}</p>`;
            groupsBreakdown.innerHTML = '<p class="text-[#9ca3af] text-sm">Fix regex error to see groups</p>';
            pythonCode.textContent = '# Fix the regex error above to generate Python code...';
            updateStats([], regexInput.value);
        }

        // Explain regex pattern components
        function explainRegexPattern(pattern) {
            const explanations = [];
            const tokens = parseRegexTokens(pattern);
            
            tokens.forEach(token => {
                const explanation = getTokenExplanation(token);
                if (explanation) {
                    explanations.push(`<div class="regex-explanation text-xs">
                        <code class="text-[#8b5cf6]">${escapeHtml(token)}</code> - ${explanation}
                    </div>`);
                }
            });
            
            return explanations.join('');
        }

        // Parse regex into tokens for explanation
        function parseRegexTokens(pattern) {
            const tokens = [];
            let i = 0;
            
            while (i < pattern.length) {
                const char = pattern[i];
                
                if (char === '\\' && i + 1 < pattern.length) {
                    // Handle escape sequences
                    tokens.push(pattern.substring(i, i + 2));
                    i += 2;
                } else if (char === '[') {
                    // Handle character classes
                    const end = pattern.indexOf(']', i + 1);
                    if (end !== -1) {
                        tokens.push(pattern.substring(i, end + 1));
                        i = end + 1;
                    } else {
                        tokens.push(char);
                        i++;
                    }
                } else if (char === '(' && i + 1 < pattern.length) {
                    // Handle groups (including special groups like (?:, (?=, etc.)
                    let depth = 1;
                    let j = i + 1;
                    let groupContent = char;
                    
                    while (j < pattern.length && depth > 0) {
                        if (pattern[j] === '\\' && j + 1 < pattern.length) {
                            groupContent += pattern.substring(j, j + 2);
                            j += 2;
                        } else {
                            if (pattern[j] === '(') depth++;
                            if (pattern[j] === ')') depth--;
                            groupContent += pattern[j];
                            j++;
                        }
                    }
                    tokens.push(groupContent);
                    i = j;
                } else if (char === '{') {
                    // Handle quantifiers like {n}, {n,}, {n,m}
                    const end = pattern.indexOf('}', i);
                    if (end !== -1) {
                        tokens.push(pattern.substring(i, end + 1));
                        i = end + 1;
                    } else {
                        tokens.push(char);
                        i++;
                    }
                } else if (char.match(/[+*?|^$.]/)) {
                    // Single character special tokens
                    tokens.push(char);
                    i++;
                } else {
                    // Collect literal characters
                    let literal = '';
                    while (i < pattern.length && !pattern[i].match(/[\\[\]()+*?{|^$.]/)) {
                        literal += pattern[i];
                        i++;
                    }
                    if (literal) tokens.push(literal);
                }
            }
            
            return tokens;
        }

        // Get explanation for a token
        function getTokenExplanation(token) {
            const explanations = {
                '\\d': 'Any digit (0-9)',
                '\\D': 'Any non-digit',
                '\\w': 'Any word character (a-z, A-Z, 0-9, _)',
                '\\W': 'Any non-word character',
                '\\s': 'Any whitespace character (space, tab, newline)',
                '\\S': 'Any non-whitespace character',
                '\\b': 'Word boundary (position between word and non-word character)',
                '\\B': 'Non-word boundary',
                '\\t': 'Tab character',
                '\\n': 'Newline character',
                '\\r': 'Carriage return',
                '.': 'Any character except newline',
                '^': 'Start of string/line',
                '$': 'End of string/line',
                '*': 'Zero or more of the preceding element',
                '+': 'One or more of the preceding element',
                '?': 'Zero or one of the preceding element (makes preceding element optional)',
                '|': 'Alternation (OR) - matches either the expression before or after',
                '(': 'Start of capturing group',
                ')': 'End of capturing group',
                '(?:': 'Start of non-capturing group',
                '(?=': 'Positive lookahead assertion',
                '(?!': 'Negative lookahead assertion',
                '(?<=': 'Positive lookbehind assertion',
                '(?<!': 'Negative lookbehind assertion'
            };
            
            if (explanations[token]) {
                return explanations[token];
            }
            
            // Handle character classes
            if (token.startsWith('[') && token.endsWith(']')) {
                if (token.startsWith('[^')) {
                    return `Negated character class - matches any character NOT in: ${token.slice(2, -1)}`;
                } else {
                    return `Character class - matches any character in: ${token.slice(1, -1)}`;
                }
            }
            
            // Handle quantifiers
            if (token.startsWith('{') && token.endsWith('}')) {
                const content = token.slice(1, -1);
                if (content.includes(',')) {
                    const [min, max] = content.split(',');
                    if (max === '') {
                        return `Quantifier - ${min} or more repetitions`;
                    } else {
                        return `Quantifier - between ${min} and ${max} repetitions`;
                    }
                } else {
                    return `Quantifier - exactly ${content} repetitions`;
                }
            }
            
            // Handle named groups
            if (token.startsWith('(?P<') && token.includes('>')) {
                const nameEnd = token.indexOf('>');
                const groupName = token.slice(4, nameEnd);
                return `Named capturing group "${groupName}"`;
            }
            
            // Handle groups
            if (token.startsWith('(') && token.endsWith(')')) {
                if (token.startsWith('(?:')) {
                    return 'Non-capturing group';
                } else if (token.startsWith('(?=')) {
                    return 'Positive lookahead - matches if followed by the pattern inside';
                } else if (token.startsWith('(?!')) {
                    return 'Negative lookahead - matches if NOT followed by the pattern inside';
                } else if (token.startsWith('(?<=')) {
                    return 'Positive lookbehind - matches if preceded by the pattern inside';
                } else if (token.startsWith('(?<!')) {
                    return 'Negative lookbehind - matches if NOT preceded by the pattern inside';
                } else {
                    return 'Capturing group - captures the matched text for later use';
                }
            }
            
            // Handle literal text
            if (token.length > 1 && !token.match(/[\\[\](){}]/)) {
                return `Literal text "${token}" - matches this exact sequence`;
            }
            
            return null;
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize the application
        init();

        // Set basic level as default
        document.getElementById('basicLevel').click();
    </script>
</body>
</html>
